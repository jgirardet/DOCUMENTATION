{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\ud83d\uddc3\ufe0f SOMMAIRE \ud83d\udcd1 PR\u00c9SENTATION \ud83e\udde9 ORGANISATION \ud83d\udc0d TUTORIELS PYXEL / PYTHON \ud83d\udc31 TUTORIELS SCRATCH retour sur le site de la Nuit du c0de .","title":"\ud83d\uddc3\ufe0f SOMMAIRE"},{"location":"#sommaire","text":"\ud83d\udcd1 PR\u00c9SENTATION \ud83e\udde9 ORGANISATION \ud83d\udc0d TUTORIELS PYXEL / PYTHON \ud83d\udc31 TUTORIELS SCRATCH retour sur le site de la Nuit du c0de .","title":"\ud83d\uddc3\ufe0f SOMMAIRE"},{"location":"01-presentation/","text":"PR\u00c9SENTATION La Nuit du c0de : cr\u00e9er un jeu avec Scratch ou Python en 6h ! PR\u00c9SENTATION G\u00c9N\u00c9RALE La Nuit du c0de est un marathon de programmation Scratch et Python organis\u00e9 par le Lyc\u00e9e Fran\u00e7ais International de Tokyo. Il s'adresse \u00e0 tous les \u00e9tablissements scolaires fran\u00e7ais (cours moyen / coll\u00e8ge / lyc\u00e9e) de l'\u00e9tranger et de France. Par \u00e9quipes de deux ou trois r\u00e9parties en plusieurs cat\u00e9gories (cycle 3, cycle 4 et lyc\u00e9e), les \u00e9l\u00e8ves ont six heures (ou moins pour les \u00e9l\u00e8ves de cycle 3) pour programmer enti\u00e8rement un jeu avec Scratch ou Python \u00e0 partir d'un univers de jeu fourni. \u00c9dition 2022 : 159 \u00e9tablissements inscrits, 4556 \u00e9l\u00e8ves, 141 villes, 38 pays. Chaque ann\u00e9e, plusieurs univers de jeu sont propos\u00e9s. Ces univers de jeux sont mis \u00e0 dispositions des organisateurs 48h avant la date choisie par l'\u00e9tablissement pour organiser la Nuit du c0de . Les \u00e9l\u00e8ves d\u00e9couvrent ces univers de jeu au d\u00e9but de la Nuit du c0de et les \u00e9quipes doivent en choisir un. Un univers de jeu contient tous les \u00e9l\u00e9ments, sons et arri\u00e8re-plans n\u00e9cessaires pour cr\u00e9er le jeu. Pour pr\u00e9parer les \u00e9l\u00e8ves durant l'ann\u00e9e, des fiches, des tutoriels, des vid\u00e9os et des sujets d'entra\u00eenement sont fournis. La pr\u00e9paration peut se faire en pr\u00e9sence d'enseignants mais elle peut aussi se faire de fa\u00e7on autonome. Les \u00e9l\u00e8ves n'ont pas besoin d'avoir des connaissances particuli\u00e8res en Scratch et Python en d\u00e9but d'ann\u00e9e pour participer \u00e0 la Nuit du c0de . Quelques s\u00e9ances de pr\u00e9paration et un peu de travail en autonomie suffisent. Durant l'\u00e9v\u00e9nement, les \u00e9l\u00e8ves mettront \u00e0 l'\u00e9preuve leur capacit\u00e9 \u00e0 travailler en groupe, leurs comp\u00e9tences en algorithmique et en math\u00e9matiques ainsi que leur cr\u00e9ativit\u00e9 (les univers de jeu sont tr\u00e8s vari\u00e9s et laissent une grande place \u00e0 l'imagination et \u00e0 la construction de sc\u00e9narios). Pendant la Nuit du c0de , les \u00e9l\u00e8ves peuvent demander de l'aide aux professeurs qui les encadrent, \u00e9changer entre \u00e9quipes, partager leurs connaissances... Les principaux crit\u00e8res d'\u00e9valuation sont la jouabilit\u00e9 , la cr\u00e9ativit\u00e9 et l' originalit\u00e9 . Le budget n\u00e9cessaire pour organiser la Nuit du c0de au sein d'un \u00e9tablissement peut \u00eatre quasi nul. Il suffit de quelques ordinateurs connect\u00e9s \u00e0 internet (un ou plus par \u00e9quipe), une ou plusieurs salles et des encadrants. La nourriture et les boissons peuvent \u00eatre pris en charge par les familles. Mais il est aussi possible, si le budget le permet, de pr\u00e9voir des pizzas, des g\u00e2teaux, des \"goodies\" (autocollants et badges par exemple), des r\u00e9compenses... La Nuit du c0de est avant tout un \u00e9v\u00e9nement festif et convivial. Chaque \u00e9tablissement peut inscrire autant d'\u00e9l\u00e8ves qu'il le souhaite, il n'y a pas de limite sur le nombre de participants. Les inscriptions sont gratuites. Pour se faire une id\u00e9e : Vid\u00e9os des \u00e9ditions pr\u00e9c\u00e9dentes Univers de jeu des \u00e9ditions pr\u00e9c\u00e9dentes Compte Twitter de la Nuit du c0de (informations, images ,vid\u00e9os...) La participation d'un \u00e9tablissement peut \u00eatre l'occasion de la cr\u00e9ation d'un atelier de programmation pour les \u00e9l\u00e8ves. Les activit\u00e9s de programmation au coll\u00e8ge, en math\u00e9matiques ou en technologie, peuvent aussi \u00eatre orient\u00e9es \u00ab jeu \u00bb (gestion des d\u00e9placements, utilisation de variables pour compter les points...). De m\u00eame, pour Python, la pr\u00e9paration \u00e0 la Nuit du c0de peut \u00eatre int\u00e9gr\u00e9e aux cours de NSI (boucles, listes, variables, fonctions, programmation orient\u00e9e objet... ). Les tutoriels propos\u00e9s pour pr\u00e9parer la Nuit du c0de peuvent \u00eatre modifi\u00e9s et servir de supports de cours. LES GRANDES LIGNES Chaque \u00e9tablissement inscrit autant d'\u00e9l\u00e8ves qu'il le souhaite. Il n'y a pas de frais d'inscription. Le budget n\u00e9cessaire peut aller de z\u00e9ro \u00e0 quelques centaines d'euros. Des ressources, tutoriels et supports, ainsi que des sujets d'entra\u00eenements seront fournis \u00e0 chaque \u00e9tablissement participant. Chaque \u00e9tablissement organise sa Nuit du c0de avec ses \u00e9l\u00e8ves. Au terme de l'\u00e9preuve, chaque \u00e9tablissement \u00e9lit ses \u00e9quipes championnes qui le repr\u00e9senteront dans chaque cat\u00e9gorie. Une s\u00e9lection mondiale est ensuite \u00e9tablie. CALENDRIER Septembre 2022 - Avril 2023 : Inscriptions Si le projet vous int\u00e9resse, vous pouvez vous inscrire sur le site nuitducode.net . Vous aurez alors acc\u00e8s \u00e0 tous les documents, ressources, tutoriels, supports... qui vous permettront de pr\u00e9parer et mettre en place la Nuit du c0de . Tout est fait pour que la charge de travail des personnes qui organiseront la Nuit du c0de dans un \u00e9tablissement soit la plus l\u00e9g\u00e8re possible. Janvier \u2013 Mai 2023 : Entra\u00eenements / Formation / S\u00e9lections Les \u00e9tablissements inscrits auront acc\u00e8s \u00e0 de nombreuses ressources : tutoriels, vid\u00e9os, guides, espace de discussions... Des univers de jeu avec grilles d'\u00e9valuation seront aussi disponibles. Ils pourront \u00eatre utilis\u00e9s soit pour organiser des s\u00e9ances d'entra\u00eenement avec les \u00e9l\u00e8ves, soit comme sujets de s\u00e9lection (si le nombre d'\u00e9l\u00e8ves souhaitant participer est sup\u00e9rieur \u00e0 la capacit\u00e9 d'accueil de l'\u00e9tablissement). Soit les deux. 1er Mai \u2013 27 Mai 2023 : Nuit du c0de Les \u00e9tablissements inscrits recevront 48h avant la date qu'ils auront fix\u00e9e pour la Nuit du c0de , les univers de jeu qui seront propos\u00e9s aux \u00e9l\u00e8ves. Ces sujets sont confidentiels ! L'\u00e9preuve demande un minimum de logistique : ordinateurs en nombre suffisant (d'o\u00f9 la possible n\u00e9cessit\u00e9 d'organiser des s\u00e9lections), des encadrants, nourriture et boissons pour les personnes pr\u00e9sentes. Si des regroupements d'\u00e9tablissements proches sont possibles, ils sont encourag\u00e9s. D\u00e9but juin 2023 : annonce de la s\u00e9lection \"Nuit du c0de 2023\" Huit jeux par cat\u00e9gories seront s\u00e9lectionn\u00e9s par un jury d'enseignants. Pour toute question et demande de pr\u00e9cisions, vous pouvez utiliser l' espace de discussions ou prendre contact avec l'\u00e9quipe organisatrice en \u00e9crivant \u00e0 contact@nuitducode.net . LA NUIT DU C0DE EN IMAGES - \u00c9DITION 2022 Vid\u00e9os, images, t\u00e9moignages et informations sur le compte Twitter de la Nuit du c0de .","title":"PR\u00c9SENTATION"},{"location":"01-presentation/#presentation","text":"La Nuit du c0de : cr\u00e9er un jeu avec Scratch ou Python en 6h !","title":"PR\u00c9SENTATION"},{"location":"01-presentation/#presentation-generale","text":"La Nuit du c0de est un marathon de programmation Scratch et Python organis\u00e9 par le Lyc\u00e9e Fran\u00e7ais International de Tokyo. Il s'adresse \u00e0 tous les \u00e9tablissements scolaires fran\u00e7ais (cours moyen / coll\u00e8ge / lyc\u00e9e) de l'\u00e9tranger et de France. Par \u00e9quipes de deux ou trois r\u00e9parties en plusieurs cat\u00e9gories (cycle 3, cycle 4 et lyc\u00e9e), les \u00e9l\u00e8ves ont six heures (ou moins pour les \u00e9l\u00e8ves de cycle 3) pour programmer enti\u00e8rement un jeu avec Scratch ou Python \u00e0 partir d'un univers de jeu fourni. \u00c9dition 2022 : 159 \u00e9tablissements inscrits, 4556 \u00e9l\u00e8ves, 141 villes, 38 pays. Chaque ann\u00e9e, plusieurs univers de jeu sont propos\u00e9s. Ces univers de jeux sont mis \u00e0 dispositions des organisateurs 48h avant la date choisie par l'\u00e9tablissement pour organiser la Nuit du c0de . Les \u00e9l\u00e8ves d\u00e9couvrent ces univers de jeu au d\u00e9but de la Nuit du c0de et les \u00e9quipes doivent en choisir un. Un univers de jeu contient tous les \u00e9l\u00e9ments, sons et arri\u00e8re-plans n\u00e9cessaires pour cr\u00e9er le jeu. Pour pr\u00e9parer les \u00e9l\u00e8ves durant l'ann\u00e9e, des fiches, des tutoriels, des vid\u00e9os et des sujets d'entra\u00eenement sont fournis. La pr\u00e9paration peut se faire en pr\u00e9sence d'enseignants mais elle peut aussi se faire de fa\u00e7on autonome. Les \u00e9l\u00e8ves n'ont pas besoin d'avoir des connaissances particuli\u00e8res en Scratch et Python en d\u00e9but d'ann\u00e9e pour participer \u00e0 la Nuit du c0de . Quelques s\u00e9ances de pr\u00e9paration et un peu de travail en autonomie suffisent. Durant l'\u00e9v\u00e9nement, les \u00e9l\u00e8ves mettront \u00e0 l'\u00e9preuve leur capacit\u00e9 \u00e0 travailler en groupe, leurs comp\u00e9tences en algorithmique et en math\u00e9matiques ainsi que leur cr\u00e9ativit\u00e9 (les univers de jeu sont tr\u00e8s vari\u00e9s et laissent une grande place \u00e0 l'imagination et \u00e0 la construction de sc\u00e9narios). Pendant la Nuit du c0de , les \u00e9l\u00e8ves peuvent demander de l'aide aux professeurs qui les encadrent, \u00e9changer entre \u00e9quipes, partager leurs connaissances... Les principaux crit\u00e8res d'\u00e9valuation sont la jouabilit\u00e9 , la cr\u00e9ativit\u00e9 et l' originalit\u00e9 . Le budget n\u00e9cessaire pour organiser la Nuit du c0de au sein d'un \u00e9tablissement peut \u00eatre quasi nul. Il suffit de quelques ordinateurs connect\u00e9s \u00e0 internet (un ou plus par \u00e9quipe), une ou plusieurs salles et des encadrants. La nourriture et les boissons peuvent \u00eatre pris en charge par les familles. Mais il est aussi possible, si le budget le permet, de pr\u00e9voir des pizzas, des g\u00e2teaux, des \"goodies\" (autocollants et badges par exemple), des r\u00e9compenses... La Nuit du c0de est avant tout un \u00e9v\u00e9nement festif et convivial. Chaque \u00e9tablissement peut inscrire autant d'\u00e9l\u00e8ves qu'il le souhaite, il n'y a pas de limite sur le nombre de participants. Les inscriptions sont gratuites. Pour se faire une id\u00e9e : Vid\u00e9os des \u00e9ditions pr\u00e9c\u00e9dentes Univers de jeu des \u00e9ditions pr\u00e9c\u00e9dentes Compte Twitter de la Nuit du c0de (informations, images ,vid\u00e9os...) La participation d'un \u00e9tablissement peut \u00eatre l'occasion de la cr\u00e9ation d'un atelier de programmation pour les \u00e9l\u00e8ves. Les activit\u00e9s de programmation au coll\u00e8ge, en math\u00e9matiques ou en technologie, peuvent aussi \u00eatre orient\u00e9es \u00ab jeu \u00bb (gestion des d\u00e9placements, utilisation de variables pour compter les points...). De m\u00eame, pour Python, la pr\u00e9paration \u00e0 la Nuit du c0de peut \u00eatre int\u00e9gr\u00e9e aux cours de NSI (boucles, listes, variables, fonctions, programmation orient\u00e9e objet... ). Les tutoriels propos\u00e9s pour pr\u00e9parer la Nuit du c0de peuvent \u00eatre modifi\u00e9s et servir de supports de cours.","title":"PR\u00c9SENTATION G\u00c9N\u00c9RALE"},{"location":"01-presentation/#les-grandes-lignes","text":"Chaque \u00e9tablissement inscrit autant d'\u00e9l\u00e8ves qu'il le souhaite. Il n'y a pas de frais d'inscription. Le budget n\u00e9cessaire peut aller de z\u00e9ro \u00e0 quelques centaines d'euros. Des ressources, tutoriels et supports, ainsi que des sujets d'entra\u00eenements seront fournis \u00e0 chaque \u00e9tablissement participant. Chaque \u00e9tablissement organise sa Nuit du c0de avec ses \u00e9l\u00e8ves. Au terme de l'\u00e9preuve, chaque \u00e9tablissement \u00e9lit ses \u00e9quipes championnes qui le repr\u00e9senteront dans chaque cat\u00e9gorie. Une s\u00e9lection mondiale est ensuite \u00e9tablie.","title":"LES GRANDES LIGNES"},{"location":"01-presentation/#calendrier","text":"","title":"CALENDRIER"},{"location":"01-presentation/#septembre-2022-avril-2023-inscriptions","text":"Si le projet vous int\u00e9resse, vous pouvez vous inscrire sur le site nuitducode.net . Vous aurez alors acc\u00e8s \u00e0 tous les documents, ressources, tutoriels, supports... qui vous permettront de pr\u00e9parer et mettre en place la Nuit du c0de . Tout est fait pour que la charge de travail des personnes qui organiseront la Nuit du c0de dans un \u00e9tablissement soit la plus l\u00e9g\u00e8re possible.","title":"Septembre 2022 - Avril 2023 : Inscriptions"},{"location":"01-presentation/#janvier-mai-2023-entrainements-formation-selections","text":"Les \u00e9tablissements inscrits auront acc\u00e8s \u00e0 de nombreuses ressources : tutoriels, vid\u00e9os, guides, espace de discussions... Des univers de jeu avec grilles d'\u00e9valuation seront aussi disponibles. Ils pourront \u00eatre utilis\u00e9s soit pour organiser des s\u00e9ances d'entra\u00eenement avec les \u00e9l\u00e8ves, soit comme sujets de s\u00e9lection (si le nombre d'\u00e9l\u00e8ves souhaitant participer est sup\u00e9rieur \u00e0 la capacit\u00e9 d'accueil de l'\u00e9tablissement). Soit les deux.","title":"Janvier \u2013 Mai 2023 : Entra\u00eenements / Formation / S\u00e9lections"},{"location":"01-presentation/#1er-mai-27-mai-2023-nuit-du-c0de","text":"Les \u00e9tablissements inscrits recevront 48h avant la date qu'ils auront fix\u00e9e pour la Nuit du c0de , les univers de jeu qui seront propos\u00e9s aux \u00e9l\u00e8ves. Ces sujets sont confidentiels ! L'\u00e9preuve demande un minimum de logistique : ordinateurs en nombre suffisant (d'o\u00f9 la possible n\u00e9cessit\u00e9 d'organiser des s\u00e9lections), des encadrants, nourriture et boissons pour les personnes pr\u00e9sentes. Si des regroupements d'\u00e9tablissements proches sont possibles, ils sont encourag\u00e9s.","title":"1er Mai \u2013 27 Mai 2023 : Nuit du c0de"},{"location":"01-presentation/#debut-juin-2023-annonce-de-la-selection-nuit-du-c0de-2023","text":"Huit jeux par cat\u00e9gories seront s\u00e9lectionn\u00e9s par un jury d'enseignants. Pour toute question et demande de pr\u00e9cisions, vous pouvez utiliser l' espace de discussions ou prendre contact avec l'\u00e9quipe organisatrice en \u00e9crivant \u00e0 contact@nuitducode.net .","title":"D\u00e9but juin 2023 : annonce de la s\u00e9lection \"Nuit du c0de 2023\""},{"location":"01-presentation/#la-nuit-du-c0de-en-images-edition-2022","text":"Vid\u00e9os, images, t\u00e9moignages et informations sur le compte Twitter de la Nuit du c0de .","title":"LA NUIT DU C0DE EN IMAGES - \u00c9DITION 2022"},{"location":"02-organisation/","text":"ORGANISATION Ce document s\u2019adresse aux \u00e9quipes enseignantes et de direction dont les \u00e9tablissements participeront \u00e0 la Nuit du c0de . Le Lyc\u00e9e Fran\u00e7ais International de Tokyo, organisateur de l\u2019\u00e9v\u00e9nement, se charge de l\u2019\u00e9laboration et de la diffusion de tous les documents n\u00e9cessaires \u00e0 la mise en place de ce marathon de programmation Scratch et Python. L\u2019\u00e9v\u00e9nement dure 6 heures (ou moins pour \u00e9l\u00e8ves de cycle 3). Pour pouvoir l'organiser dans de bonnes conditions, plusieurs \u00e9l\u00e9ments sont \u00e0 prendre en compte. T\u00c2CHES PRIORITAIRES Rappel Tout est fait pour que la charge de travail du ou des organisateurs soit la plus l\u00e9g\u00e8re possible. Documents, guides, supports, mod\u00e8les..., tout est fourni (voir \"Ressources\" et la suite de ce document). D\u00e9signer un ou plusieurs organisateur(s) La Nuit du c0de peut \u00eatre organis\u00e9e au sein d'un \u00e9tablissement par une seule personne ou par plusieurs. Diff\u00e9rentes \u00e9quipes p\u00e9dagogiques peuvent s'impliquer. Scientifiques ou non. Par exemple, les enseignants d'Arts Plastiques peuvent contribuer \u00e0 la mise en place l'\u00e9v\u00e9nement (cr\u00e9ation de supports visuels, d\u00e9coration de l'\u00e9tablissement et/ou des salles, dessins vectoriels...). Si plusieurs personnes participent \u00e0 l'organisation de l'\u00e9v\u00e9nement, il est conseill\u00e9 de d\u00e9finir un coordinateur qui se chargera d'inscrire l'\u00e9tablissement, de faire le lien avec la direction et de faire le suivi gr\u00e2ce au site. Inscrire l'\u00e9tablissement L'inscription se fait sur le site de la Nuit du c0de . Les param\u00e8tres de connexion alors cr\u00e9\u00e9s permettent d'acc\u00e9der \u00e0 un espace de gestion de l'\u00e9v\u00e9nement (suivi de l'organisation, ressources, interface pour enregistrer et \u00e9valuer les jeux...). Choisir la date de la Nuit du c0de Ce choix de la date n'est pas urgent. Il peut se faire en d\u00e9but ou milieu de deuxi\u00e8me trimestre en concertation direction. Cette date doit cependant \u00eatre communiqu\u00e9e suffisamment t\u00f4t afin de laisser du temps aux organisateurs et de permettre aux familles de s'organiser (surtout si elle tombe un samedi). D\u00e9finir un budget Le budget n\u00e9cessaire pour organiser la Nuit du c0de au sein d'un \u00e9tablissement peut \u00eatre quasi nul. La nourriture et les boissons peuvent \u00eatre pris en charge par les familles et il n'est pas obligatoire de pr\u00e9voir des prix. Un dipl\u00f4me imprim\u00e9 et une petite c\u00e9r\u00e9monie peuvent suffire. Mais il est aussi possible, si le budget le permet, de pr\u00e9voir des commandes de pizzas, des g\u00e2teaux, des \"goodies\" (autocollants et badges par exemple), des r\u00e9compenses... Pr\u00e9voir l'\u00e9quipement informatique Pour organiser la Nuit du c0de dans votre \u00e9tablissement, vous aurez besoin d'ordinateurs fixes ou portables ou de tablettes (un appareil ou plus par \u00e9quipe). Pr\u00e9voir des terminaux (ordinateurs/tablettes) disponibles en nombre suffisant. Il est crucial de v\u00e9rifier votre capacit\u00e9 d\u2019accueil. Les \u00e9l\u00e8ves peuvent apporter leur propre terminal. Le jeu peut se faire soit en ligne (dans ce cas les \u00e9l\u00e8ves devront avoir un compte pour se connecter) soit en d\u00e9connect\u00e9 (installation de Scratch 3 n\u00e9cessaire sur les terminaux utilis\u00e9s). Pour Python, la derni\u00e8re version de Pyxel doit \u00eatre install\u00e9e sur les terminaux (voir Installation de Pyxel ). Pr\u00e9voir aussi des casques et des souris pour faciliter la cr\u00e9ations des jeux. Pr\u00e9voir une ou plusieurs salles Pr\u00e9voir un ou des espaces suffisament grands. Les \u00e9quipes doivent avoir une surface de travail confortable. De plus, pendant toute la dur\u00e9e de l\u2019\u00e9preuve, on encourage les \u00e9l\u00e8ves \u00e0 aller observer le travail des autres, \u00e0 \u00e9changer, s'entraider... Il faut donc que les \u00e9l\u00e8ves (tout comme les encadrants) puissent circuler aisement. + d'un espace pour la nourriture et les boissons Pr\u00e9parer les \u00e9l\u00e8ves La Nuit du c0de est avant tout une f\u00eate et un jeu. Et pour que les \u00e9l\u00e8ves puissent pleinement en profiter, il est pr\u00e9f\u00e9rable qu\u2019ils soient pr\u00e9par\u00e9s \u00e0 la nature de l\u2019\u00e9v\u00e9nement. L\u2019\u00e9quipe de la Nuit du c0de met \u00e0 votre disposition des ressources Scratch et Python pour organiser des entra\u00eenements. Il est important que les \u00e9l\u00e8ves participants puissent s\u2019entra\u00eener un minimum quelles que soient les modalit\u00e9s (en classe, en atelier p\u00e9riscolaire, \u00e0 la maison, en temps libre ou limit\u00e9, avec des contraintes pr\u00e9cises ou de fa\u00e7on totalement autonome). La Nuit du c0de se joue en \u00e9quipes (de 2 ou 3 \u00e9l\u00e8ves) et cela demande aux \u00e9l\u00e8ves des qualit\u00e9s de collaboration et d\u2019organisation. Cela n\u00e9cessite donc un peu de pr\u00e9paration. Pr\u00e9voir une \u00e9quipe d'encadrants pour le jour J La Nuit du c0de est l'occasion d'impliquer les \u00e9quipes \u00e9ducatives, la direction et m\u00eame les parents. Le jour de l'\u00e9v\u00e9nement, il faut pr\u00e9voir suffisamment de personnes pour encadrer les \u00e9l\u00e8ves et aider \u00e0 la mise en place, \u00e0 la logistique et au rangement. Il n'est pas n\u00e9cessaire que toutes ces personnes ma\u00eetrisent la programmation Scratch ou Python. De plus, les encadrants ne sont pas oblig\u00e9s d'\u00eatre pr\u00e9sents sur toute la dur\u00e9e de l'\u00e9v\u00e9nement. Des cr\u00e9neaux peuvent \u00eatre d\u00e9finis et un tableau de pr\u00e9sence peut \u00eatre mis en place. Les moments qui n\u00e9cessitent un encadrement accru sont au d\u00e9but, lors de la pause nourriture / boissons et \u00e0 la fin de l'\u00e9v\u00e9nement. Penser aux autorisations parentales Il peut \u00eatre n\u00e9cessaire d'obtenir des autorisations parentales. Notamment si l'\u00e9v\u00e9nement est programm\u00e9 en dehors des heures de cours. Cette d\u00e9marche peut prendre du temps (d\u00e9lais de r\u00e9ponse des familles, relances, corrections...). Une bonne anticipation est donc n\u00e9cessaire. Des mod\u00e8les de lettre \u00e0 envoyer aux familles sont propos\u00e9s (voir \"Ressources\" ). Pr\u00e9voir \u00e0 manger et \u00e0 boire L'\u00e9preuve est longue et nos jeunes codeurs ne tiendront pas 6 heures sans s\u2019alimenter ! De plus, la Nuit du c0de se veut un \u00e9v\u00e9nement convivial. La ou les pauses nourriture / boissons y contribuent. Pr\u00e9voir un coin snack et buvette est donc important et fait partie de cette ambiance qui doit \u00eatre d\u00e9tendue et m\u00eame festive. Les services de cantine peuvent \u00eatre sollicit\u00e9s. T\u00c2CHES FACULTATIVES Communiquer Des affiches, des mod\u00e8les d'annonce et de courriels (\u00e0 l'attention des \u00e9l\u00e8ves ou des familles) et un court diaporama de pr\u00e9sentation de la Nuit du c0de sont propos\u00e9s (voir \"Ressources\" ). Vous pouvez ainsi solliciter des coll\u00e8gues pour qu'ils pr\u00e9sentent le diaporama au d\u00e9but d'un de leurs cours. Vous pouvez aussi publier des annonces sur le site de l'\u00e9tablissement ou via la lettre d'information. Pr\u00e9voir des \"Goodies\" / r\u00e9compenses Si le budget le permet, vous pouvez pr\u00e9voir des \"goodies\" (autocollants, badges, tasses...). Plusieurs visuels sont \u00e0 votre disposition (voir \"Ressources\" ). Ils peuvent \u00eatre offerts \u00e0 tous les \u00e9l\u00e8ves participants. Chaque \u00e9tablissement peut aussi d\u00e9cider de r\u00e9compenser ses meilleures \u00e9quipes en leur offrant un prix. Mais ceci est optionnel. Une petite c\u00e9r\u00e9monie avec remise de dipl\u00f4mes suffit pour marquer la fin de l'\u00e9v\u00e9nement et faire plaisir aux \u00e9l\u00e8ves. Organiser des s\u00e9lections Vous pourrez avoir besoin de r\u00e9aliser des s\u00e9lections si le nombre d\u2019\u00e9l\u00e8ves qui souhaitent participer d\u00e9passe la capacit\u00e9 d\u2019accueil de votre \u00e9tablissement (en mati\u00e8re de connexion \u00e0 Internet ou de nombre d\u2019ordinateurs / tablettes disponibles). Des ressources Scratch ou Python sont pr\u00e9sentes sur le site pour organiser ces s\u00e9lections. Ces ressources vous permettront, si vous le souhaitez, de tester le niveau de vos \u00e9l\u00e8ves et, \u00e9ventuellement, de les s\u00e9lectionner. Il est conseill\u00e9 de faire ces \u00e9valuations en \u00e9quipes. Solliciter des intervenants Si vous avez la possibilit\u00e9 de faire venir, en ouverture de la Nuit du c0de , un ou plusieurs intervenants capables de pr\u00e9senter le monde de la programmation ou du jeu vid\u00e9o, n'h\u00e9sitez pas. Ces pr\u00e9sentations (qui doivent \u00eatre courtes) permettent de lancer en douceur l'\u00e9v\u00e9nement et peuvent s'inscrire dans la cadre du travail d'orientation des \u00e9l\u00e8ves. Les intervenants peuvent aussi \u00eatre des \u00e9l\u00e8ves qui pr\u00e9sentent un projet qu'ils ont men\u00e9 durant l'ann\u00e9e. Proposer un regroupement d'\u00e9tablissements Si dans votre zone g\u00e9ographique plusieurs \u00e9tablissements sont int\u00e9ress\u00e9s et que la situation sanitaire le permet, regrouper les \u00e9tablissements permet de garantir un \u00e9v\u00e9nement encore plus festif et attractif. Inviter des \u00e9coles locales Pour les \u00e9tablissements fran\u00e7ais de l\u2019\u00e9tranger, inviter des \u00e9coles locales peut donner une autre dimension \u00e0 l'\u00e9v\u00e9nement. Cela permet de cr\u00e9er des \u00e9quipes mixtes, de favoriser les \u00e9changes entre les \u00e9quipes (enseignantes et/ou de direction) des diff\u00e9rents \u00e9tablissements et de tisser des liens qui peuvent d\u00e9boucher sur d'autres projets communs. NUIT DU C0DE et PROGRAMMES La pr\u00e9paration des \u00e9l\u00e8ves peut aussi se faire dans le cadre des programmes de coll\u00e8ge / lyc\u00e9e pour Scratch (en technologie, math\u00e9matiques, SNT...) ou de NSI pour Python. Pour faciliter cette int\u00e9gration dans les programmes, un groupe de travail s'est constitu\u00e9 et plusieurs ressources sont en cours de cr\u00e9ation. Si vous souhaitez rejoindre le groupe de travail, vous pouvez \u00e9crire \u00e0 contact@nuitducode.net . POUR LE JOUR J \u00c0 quelques jours de la Nuit du c0de, des v\u00e9rifications s'imposent : V\u00e9rifier les salles V\u00e9rifier l'\u00e9quipement informatique Faire le point avec l'\u00e9quipe d'encadrement V\u00e9rifier que les documents \u00e0 distribuer aux \u00e9quipes sont imprim\u00e9s (voir \"Ressources\" ) S'assurer que la nourriture et les boissons sont en quantit\u00e9s suffisantes S'assurer que les \"goodies\" / r\u00e9compenses sont pr\u00eats (si cela est pr\u00e9vu) Confirmer la pr\u00e9sence du ou des intervenants (si cela est pr\u00e9vu) Faire le point avec l'\u00e9tablissement invit\u00e9 (si cela est pr\u00e9vu) \u00c9VALUATION DES JEUX Pr\u00e9voir un temps pour l\u2019\u00e9valuation de tous les jeux cr\u00e9\u00e9s pendant la Nuit du c0de . Chaque \u00e9tablissement doit s\u00e9lectionner ses \u00e9quipes championnes. Il est important d\u2019associer les \u00e9l\u00e8ves dans cette s\u00e9lection. Cela peut se faire tout de suite apr\u00e8s l\u2019\u00e9preuve, lors d\u2019un autre moment banalis\u00e9, \u00e0 la maison... Cela d\u00e9pend du nombre d\u2019\u00e9quipes participantes dans votre \u00e9tablissement. L'\u00e9valuation des jeux se fera via le site. FEUILLE DE ROUTE & RESSOURCES Cas d'une organisation minimale (pas de commande de nourriture / boissons, pas de \"goodies\", pas d'intervenants, pas de r\u00e9compenses...). Actions P\u00e9riode approximative Personnes impliqu\u00e9es Ressources Inscrire l'\u00e9tablissement de septembre 2022 \u00e0 avril 2023 organisateur(s) www.nuitducode.net Choisir la date de l'\u00e9v\u00e9nement de septembre 2022 \u00e0 avril 2023 organisateur(s) / direction Inscrire les \u00e9l\u00e8ves et les \u00e9quipes de septembre 2022 \u00e0 avril 2023 organisateur(s) mode d'emploi et mod\u00e8les disponibles prochainement Communiquer de septembre 2022 \u00e0 avril 2023 organisateur(s) / \u00e9quipes enseignantes / direction affiches, diaporama, mod\u00e8les de courriels / annonces disponibles prochainement Entra\u00eener / s\u00e9lectionner les \u00e9l\u00e8ves de janvier \u00e0 avril 2023 organisateur(s) / \u00e9quipes enseignantes tutoriels et sujets d'entra\u00eenement / s\u00e9lection disponibles prochainement Pr\u00e9voir nourriture et boissons avril / mai 2023 organisateur(s) / \u00e9quipes enseignantes / direction / familles Choisir les salles avril / mai 2023 organisateur(s) / direction Pr\u00e9parer le jour J mai 2023 organisateur(s) / \u00e9quipes enseignantes / direction / familles documents \"R\u00e8gles et conseils\" / \"Carnet de bord\" disponibles prochainement \u00c9valuer les jeux mai 2023 organisateur(s) / \u00e9quipes enseignantes / \u00e9l\u00e8ves www.nuitducode.net Organiser une remise de diplomes \u00e0 la fin de la Nuit du c0de ou quelques jours plus tard organisateur(s) / \u00e9quipes enseignantes / direction / familles mod\u00e8les de diplomes disponibles prochainement UN EXEMPLE D\u2019ORGANISATION Attention, il s\u2019agit bien d\u2019un exemple, et non pas d\u2019un mod\u00e8le. Voici les principaux points concernant l'organisation de la Nuit du c0de au Lyc\u00e9e Fran\u00e7ais International de Tokyo : Le Lyc\u00e9e Fran\u00e7ais International de Tokyo accueillera les \u00e9l\u00e8ves du Lyc\u00e9e Fran\u00e7ais International de Kyoto et d'une \u00e9cole japonaise locale. Deux ou trois intervenants ext\u00e9rieurs viendront faire de courtes pr\u00e9sentations. Chaque \u00e9l\u00e8ve sera \u00e9quip\u00e9 d'un Chromebook. L'\u00e9tablissement sera d\u00e9cor\u00e9 par des \u00e9l\u00e8ves du primaire et du secondaire (th\u00e8mes pixel-art et r\u00e9tro-gaming). Un buffet (pizzas, snacks vari\u00e9s et boissons) sera propos\u00e9 durant l\u2019\u00e9v\u00e9nement. Les jeux r\u00e9alis\u00e9s seront test\u00e9s et \u00e9valu\u00e9s par les \u00e9l\u00e8ves et des enseignants tout de suite apr\u00e8s l\u2019\u00e9preuve (nous ferons une pause de 30 minutes avant). Une remise de prix se fera dans la foul\u00e9e pour les meilleures \u00e9quipes des diff\u00e9rentes cat\u00e9gories. NOUS COMPTONS SUR VOUS ! Vous l\u2019aurez compris, le bon d\u00e9roulement de la Nuit du c0de dans votre \u00e9tablissement repose en grande partie sur une bonne pr\u00e9paration. Inutile, lors d\u2019une premi\u00e8re participation de vouloir trop en faire : des ordinateurs et de quoi grignoter suffiront \u00e0 passer un tr\u00e8s bon moment. Vous pourrez toujours faire plus et mieux les ann\u00e9es suivantes ! Si des points restent peu clairs ou si ce document ne r\u00e9pond pas \u00e0 vos questions, n\u2019h\u00e9sitez pas \u00e0 utiliser l' espace de discussions ou \u00e0 prendre contact avec l'\u00e9quipe organisatrice en \u00e9crivant \u00e0 contact@nuitducode.net .","title":"ORGANISATION"},{"location":"02-organisation/#organisation","text":"Ce document s\u2019adresse aux \u00e9quipes enseignantes et de direction dont les \u00e9tablissements participeront \u00e0 la Nuit du c0de . Le Lyc\u00e9e Fran\u00e7ais International de Tokyo, organisateur de l\u2019\u00e9v\u00e9nement, se charge de l\u2019\u00e9laboration et de la diffusion de tous les documents n\u00e9cessaires \u00e0 la mise en place de ce marathon de programmation Scratch et Python. L\u2019\u00e9v\u00e9nement dure 6 heures (ou moins pour \u00e9l\u00e8ves de cycle 3). Pour pouvoir l'organiser dans de bonnes conditions, plusieurs \u00e9l\u00e9ments sont \u00e0 prendre en compte.","title":"ORGANISATION"},{"location":"02-organisation/#taches-prioritaires","text":"Rappel Tout est fait pour que la charge de travail du ou des organisateurs soit la plus l\u00e9g\u00e8re possible. Documents, guides, supports, mod\u00e8les..., tout est fourni (voir \"Ressources\" et la suite de ce document). D\u00e9signer un ou plusieurs organisateur(s) La Nuit du c0de peut \u00eatre organis\u00e9e au sein d'un \u00e9tablissement par une seule personne ou par plusieurs. Diff\u00e9rentes \u00e9quipes p\u00e9dagogiques peuvent s'impliquer. Scientifiques ou non. Par exemple, les enseignants d'Arts Plastiques peuvent contribuer \u00e0 la mise en place l'\u00e9v\u00e9nement (cr\u00e9ation de supports visuels, d\u00e9coration de l'\u00e9tablissement et/ou des salles, dessins vectoriels...). Si plusieurs personnes participent \u00e0 l'organisation de l'\u00e9v\u00e9nement, il est conseill\u00e9 de d\u00e9finir un coordinateur qui se chargera d'inscrire l'\u00e9tablissement, de faire le lien avec la direction et de faire le suivi gr\u00e2ce au site. Inscrire l'\u00e9tablissement L'inscription se fait sur le site de la Nuit du c0de . Les param\u00e8tres de connexion alors cr\u00e9\u00e9s permettent d'acc\u00e9der \u00e0 un espace de gestion de l'\u00e9v\u00e9nement (suivi de l'organisation, ressources, interface pour enregistrer et \u00e9valuer les jeux...). Choisir la date de la Nuit du c0de Ce choix de la date n'est pas urgent. Il peut se faire en d\u00e9but ou milieu de deuxi\u00e8me trimestre en concertation direction. Cette date doit cependant \u00eatre communiqu\u00e9e suffisamment t\u00f4t afin de laisser du temps aux organisateurs et de permettre aux familles de s'organiser (surtout si elle tombe un samedi). D\u00e9finir un budget Le budget n\u00e9cessaire pour organiser la Nuit du c0de au sein d'un \u00e9tablissement peut \u00eatre quasi nul. La nourriture et les boissons peuvent \u00eatre pris en charge par les familles et il n'est pas obligatoire de pr\u00e9voir des prix. Un dipl\u00f4me imprim\u00e9 et une petite c\u00e9r\u00e9monie peuvent suffire. Mais il est aussi possible, si le budget le permet, de pr\u00e9voir des commandes de pizzas, des g\u00e2teaux, des \"goodies\" (autocollants et badges par exemple), des r\u00e9compenses... Pr\u00e9voir l'\u00e9quipement informatique Pour organiser la Nuit du c0de dans votre \u00e9tablissement, vous aurez besoin d'ordinateurs fixes ou portables ou de tablettes (un appareil ou plus par \u00e9quipe). Pr\u00e9voir des terminaux (ordinateurs/tablettes) disponibles en nombre suffisant. Il est crucial de v\u00e9rifier votre capacit\u00e9 d\u2019accueil. Les \u00e9l\u00e8ves peuvent apporter leur propre terminal. Le jeu peut se faire soit en ligne (dans ce cas les \u00e9l\u00e8ves devront avoir un compte pour se connecter) soit en d\u00e9connect\u00e9 (installation de Scratch 3 n\u00e9cessaire sur les terminaux utilis\u00e9s). Pour Python, la derni\u00e8re version de Pyxel doit \u00eatre install\u00e9e sur les terminaux (voir Installation de Pyxel ). Pr\u00e9voir aussi des casques et des souris pour faciliter la cr\u00e9ations des jeux. Pr\u00e9voir une ou plusieurs salles Pr\u00e9voir un ou des espaces suffisament grands. Les \u00e9quipes doivent avoir une surface de travail confortable. De plus, pendant toute la dur\u00e9e de l\u2019\u00e9preuve, on encourage les \u00e9l\u00e8ves \u00e0 aller observer le travail des autres, \u00e0 \u00e9changer, s'entraider... Il faut donc que les \u00e9l\u00e8ves (tout comme les encadrants) puissent circuler aisement. + d'un espace pour la nourriture et les boissons Pr\u00e9parer les \u00e9l\u00e8ves La Nuit du c0de est avant tout une f\u00eate et un jeu. Et pour que les \u00e9l\u00e8ves puissent pleinement en profiter, il est pr\u00e9f\u00e9rable qu\u2019ils soient pr\u00e9par\u00e9s \u00e0 la nature de l\u2019\u00e9v\u00e9nement. L\u2019\u00e9quipe de la Nuit du c0de met \u00e0 votre disposition des ressources Scratch et Python pour organiser des entra\u00eenements. Il est important que les \u00e9l\u00e8ves participants puissent s\u2019entra\u00eener un minimum quelles que soient les modalit\u00e9s (en classe, en atelier p\u00e9riscolaire, \u00e0 la maison, en temps libre ou limit\u00e9, avec des contraintes pr\u00e9cises ou de fa\u00e7on totalement autonome). La Nuit du c0de se joue en \u00e9quipes (de 2 ou 3 \u00e9l\u00e8ves) et cela demande aux \u00e9l\u00e8ves des qualit\u00e9s de collaboration et d\u2019organisation. Cela n\u00e9cessite donc un peu de pr\u00e9paration. Pr\u00e9voir une \u00e9quipe d'encadrants pour le jour J La Nuit du c0de est l'occasion d'impliquer les \u00e9quipes \u00e9ducatives, la direction et m\u00eame les parents. Le jour de l'\u00e9v\u00e9nement, il faut pr\u00e9voir suffisamment de personnes pour encadrer les \u00e9l\u00e8ves et aider \u00e0 la mise en place, \u00e0 la logistique et au rangement. Il n'est pas n\u00e9cessaire que toutes ces personnes ma\u00eetrisent la programmation Scratch ou Python. De plus, les encadrants ne sont pas oblig\u00e9s d'\u00eatre pr\u00e9sents sur toute la dur\u00e9e de l'\u00e9v\u00e9nement. Des cr\u00e9neaux peuvent \u00eatre d\u00e9finis et un tableau de pr\u00e9sence peut \u00eatre mis en place. Les moments qui n\u00e9cessitent un encadrement accru sont au d\u00e9but, lors de la pause nourriture / boissons et \u00e0 la fin de l'\u00e9v\u00e9nement. Penser aux autorisations parentales Il peut \u00eatre n\u00e9cessaire d'obtenir des autorisations parentales. Notamment si l'\u00e9v\u00e9nement est programm\u00e9 en dehors des heures de cours. Cette d\u00e9marche peut prendre du temps (d\u00e9lais de r\u00e9ponse des familles, relances, corrections...). Une bonne anticipation est donc n\u00e9cessaire. Des mod\u00e8les de lettre \u00e0 envoyer aux familles sont propos\u00e9s (voir \"Ressources\" ). Pr\u00e9voir \u00e0 manger et \u00e0 boire L'\u00e9preuve est longue et nos jeunes codeurs ne tiendront pas 6 heures sans s\u2019alimenter ! De plus, la Nuit du c0de se veut un \u00e9v\u00e9nement convivial. La ou les pauses nourriture / boissons y contribuent. Pr\u00e9voir un coin snack et buvette est donc important et fait partie de cette ambiance qui doit \u00eatre d\u00e9tendue et m\u00eame festive. Les services de cantine peuvent \u00eatre sollicit\u00e9s.","title":"T\u00c2CHES PRIORITAIRES"},{"location":"02-organisation/#taches-facultatives","text":"Communiquer Des affiches, des mod\u00e8les d'annonce et de courriels (\u00e0 l'attention des \u00e9l\u00e8ves ou des familles) et un court diaporama de pr\u00e9sentation de la Nuit du c0de sont propos\u00e9s (voir \"Ressources\" ). Vous pouvez ainsi solliciter des coll\u00e8gues pour qu'ils pr\u00e9sentent le diaporama au d\u00e9but d'un de leurs cours. Vous pouvez aussi publier des annonces sur le site de l'\u00e9tablissement ou via la lettre d'information. Pr\u00e9voir des \"Goodies\" / r\u00e9compenses Si le budget le permet, vous pouvez pr\u00e9voir des \"goodies\" (autocollants, badges, tasses...). Plusieurs visuels sont \u00e0 votre disposition (voir \"Ressources\" ). Ils peuvent \u00eatre offerts \u00e0 tous les \u00e9l\u00e8ves participants. Chaque \u00e9tablissement peut aussi d\u00e9cider de r\u00e9compenser ses meilleures \u00e9quipes en leur offrant un prix. Mais ceci est optionnel. Une petite c\u00e9r\u00e9monie avec remise de dipl\u00f4mes suffit pour marquer la fin de l'\u00e9v\u00e9nement et faire plaisir aux \u00e9l\u00e8ves. Organiser des s\u00e9lections Vous pourrez avoir besoin de r\u00e9aliser des s\u00e9lections si le nombre d\u2019\u00e9l\u00e8ves qui souhaitent participer d\u00e9passe la capacit\u00e9 d\u2019accueil de votre \u00e9tablissement (en mati\u00e8re de connexion \u00e0 Internet ou de nombre d\u2019ordinateurs / tablettes disponibles). Des ressources Scratch ou Python sont pr\u00e9sentes sur le site pour organiser ces s\u00e9lections. Ces ressources vous permettront, si vous le souhaitez, de tester le niveau de vos \u00e9l\u00e8ves et, \u00e9ventuellement, de les s\u00e9lectionner. Il est conseill\u00e9 de faire ces \u00e9valuations en \u00e9quipes. Solliciter des intervenants Si vous avez la possibilit\u00e9 de faire venir, en ouverture de la Nuit du c0de , un ou plusieurs intervenants capables de pr\u00e9senter le monde de la programmation ou du jeu vid\u00e9o, n'h\u00e9sitez pas. Ces pr\u00e9sentations (qui doivent \u00eatre courtes) permettent de lancer en douceur l'\u00e9v\u00e9nement et peuvent s'inscrire dans la cadre du travail d'orientation des \u00e9l\u00e8ves. Les intervenants peuvent aussi \u00eatre des \u00e9l\u00e8ves qui pr\u00e9sentent un projet qu'ils ont men\u00e9 durant l'ann\u00e9e. Proposer un regroupement d'\u00e9tablissements Si dans votre zone g\u00e9ographique plusieurs \u00e9tablissements sont int\u00e9ress\u00e9s et que la situation sanitaire le permet, regrouper les \u00e9tablissements permet de garantir un \u00e9v\u00e9nement encore plus festif et attractif. Inviter des \u00e9coles locales Pour les \u00e9tablissements fran\u00e7ais de l\u2019\u00e9tranger, inviter des \u00e9coles locales peut donner une autre dimension \u00e0 l'\u00e9v\u00e9nement. Cela permet de cr\u00e9er des \u00e9quipes mixtes, de favoriser les \u00e9changes entre les \u00e9quipes (enseignantes et/ou de direction) des diff\u00e9rents \u00e9tablissements et de tisser des liens qui peuvent d\u00e9boucher sur d'autres projets communs.","title":"T\u00c2CHES FACULTATIVES"},{"location":"02-organisation/#nuit-du-c0de-et-programmes","text":"La pr\u00e9paration des \u00e9l\u00e8ves peut aussi se faire dans le cadre des programmes de coll\u00e8ge / lyc\u00e9e pour Scratch (en technologie, math\u00e9matiques, SNT...) ou de NSI pour Python. Pour faciliter cette int\u00e9gration dans les programmes, un groupe de travail s'est constitu\u00e9 et plusieurs ressources sont en cours de cr\u00e9ation. Si vous souhaitez rejoindre le groupe de travail, vous pouvez \u00e9crire \u00e0 contact@nuitducode.net .","title":"NUIT DU C0DE et PROGRAMMES"},{"location":"02-organisation/#pour-le-jour-j","text":"\u00c0 quelques jours de la Nuit du c0de, des v\u00e9rifications s'imposent : V\u00e9rifier les salles V\u00e9rifier l'\u00e9quipement informatique Faire le point avec l'\u00e9quipe d'encadrement V\u00e9rifier que les documents \u00e0 distribuer aux \u00e9quipes sont imprim\u00e9s (voir \"Ressources\" ) S'assurer que la nourriture et les boissons sont en quantit\u00e9s suffisantes S'assurer que les \"goodies\" / r\u00e9compenses sont pr\u00eats (si cela est pr\u00e9vu) Confirmer la pr\u00e9sence du ou des intervenants (si cela est pr\u00e9vu) Faire le point avec l'\u00e9tablissement invit\u00e9 (si cela est pr\u00e9vu)","title":"POUR LE JOUR J"},{"location":"02-organisation/#evaluation-des-jeux","text":"Pr\u00e9voir un temps pour l\u2019\u00e9valuation de tous les jeux cr\u00e9\u00e9s pendant la Nuit du c0de . Chaque \u00e9tablissement doit s\u00e9lectionner ses \u00e9quipes championnes. Il est important d\u2019associer les \u00e9l\u00e8ves dans cette s\u00e9lection. Cela peut se faire tout de suite apr\u00e8s l\u2019\u00e9preuve, lors d\u2019un autre moment banalis\u00e9, \u00e0 la maison... Cela d\u00e9pend du nombre d\u2019\u00e9quipes participantes dans votre \u00e9tablissement. L'\u00e9valuation des jeux se fera via le site.","title":"\u00c9VALUATION DES JEUX"},{"location":"02-organisation/#feuille-de-route-ressources","text":"Cas d'une organisation minimale (pas de commande de nourriture / boissons, pas de \"goodies\", pas d'intervenants, pas de r\u00e9compenses...). Actions P\u00e9riode approximative Personnes impliqu\u00e9es Ressources Inscrire l'\u00e9tablissement de septembre 2022 \u00e0 avril 2023 organisateur(s) www.nuitducode.net Choisir la date de l'\u00e9v\u00e9nement de septembre 2022 \u00e0 avril 2023 organisateur(s) / direction Inscrire les \u00e9l\u00e8ves et les \u00e9quipes de septembre 2022 \u00e0 avril 2023 organisateur(s) mode d'emploi et mod\u00e8les disponibles prochainement Communiquer de septembre 2022 \u00e0 avril 2023 organisateur(s) / \u00e9quipes enseignantes / direction affiches, diaporama, mod\u00e8les de courriels / annonces disponibles prochainement Entra\u00eener / s\u00e9lectionner les \u00e9l\u00e8ves de janvier \u00e0 avril 2023 organisateur(s) / \u00e9quipes enseignantes tutoriels et sujets d'entra\u00eenement / s\u00e9lection disponibles prochainement Pr\u00e9voir nourriture et boissons avril / mai 2023 organisateur(s) / \u00e9quipes enseignantes / direction / familles Choisir les salles avril / mai 2023 organisateur(s) / direction Pr\u00e9parer le jour J mai 2023 organisateur(s) / \u00e9quipes enseignantes / direction / familles documents \"R\u00e8gles et conseils\" / \"Carnet de bord\" disponibles prochainement \u00c9valuer les jeux mai 2023 organisateur(s) / \u00e9quipes enseignantes / \u00e9l\u00e8ves www.nuitducode.net Organiser une remise de diplomes \u00e0 la fin de la Nuit du c0de ou quelques jours plus tard organisateur(s) / \u00e9quipes enseignantes / direction / familles mod\u00e8les de diplomes disponibles prochainement","title":"FEUILLE DE ROUTE &amp; RESSOURCES"},{"location":"02-organisation/#un-exemple-dorganisation","text":"Attention, il s\u2019agit bien d\u2019un exemple, et non pas d\u2019un mod\u00e8le. Voici les principaux points concernant l'organisation de la Nuit du c0de au Lyc\u00e9e Fran\u00e7ais International de Tokyo : Le Lyc\u00e9e Fran\u00e7ais International de Tokyo accueillera les \u00e9l\u00e8ves du Lyc\u00e9e Fran\u00e7ais International de Kyoto et d'une \u00e9cole japonaise locale. Deux ou trois intervenants ext\u00e9rieurs viendront faire de courtes pr\u00e9sentations. Chaque \u00e9l\u00e8ve sera \u00e9quip\u00e9 d'un Chromebook. L'\u00e9tablissement sera d\u00e9cor\u00e9 par des \u00e9l\u00e8ves du primaire et du secondaire (th\u00e8mes pixel-art et r\u00e9tro-gaming). Un buffet (pizzas, snacks vari\u00e9s et boissons) sera propos\u00e9 durant l\u2019\u00e9v\u00e9nement. Les jeux r\u00e9alis\u00e9s seront test\u00e9s et \u00e9valu\u00e9s par les \u00e9l\u00e8ves et des enseignants tout de suite apr\u00e8s l\u2019\u00e9preuve (nous ferons une pause de 30 minutes avant). Une remise de prix se fera dans la foul\u00e9e pour les meilleures \u00e9quipes des diff\u00e9rentes cat\u00e9gories.","title":"UN EXEMPLE D\u2019ORGANISATION"},{"location":"02-organisation/#nous-comptons-sur-vous","text":"Vous l\u2019aurez compris, le bon d\u00e9roulement de la Nuit du c0de dans votre \u00e9tablissement repose en grande partie sur une bonne pr\u00e9paration. Inutile, lors d\u2019une premi\u00e8re participation de vouloir trop en faire : des ordinateurs et de quoi grignoter suffiront \u00e0 passer un tr\u00e8s bon moment. Vous pourrez toujours faire plus et mieux les ann\u00e9es suivantes ! Si des points restent peu clairs ou si ce document ne r\u00e9pond pas \u00e0 vos questions, n\u2019h\u00e9sitez pas \u00e0 utiliser l' espace de discussions ou \u00e0 prendre contact avec l'\u00e9quipe organisatrice en \u00e9crivant \u00e0 contact@nuitducode.net .","title":"NOUS COMPTONS SUR VOUS !"},{"location":"03-ressources/","text":"RESSOURCES LOGOS remarques : les versions 2023 sont en cours de cr\u00e9ation Pour la communication ou pour cr\u00e9er des autocollants, des t-shirts, des tasses... NDC : png - svg Scratch : png - svg Python : png - svg Scratch & Python : png - svg AFFICHES remarques : les versions 2023 sont en cours de cr\u00e9ation Plusieurs versions sont propos\u00e9es: portrait 7000x10000 pixels (6,7 Mo) portrait 3500x5000 pixels (2 Mo) portrait 1750x2500 pixels (628 ko) paysage 10000x7000 pixels (6 Mo) paysage 5000x3500 pixels (1,8 ko) paysage 2500x1750 pixels (560 ko) En pla\u00e7ant l'image en fond de page, vous pouvez utiliser le logiciel de traitement de texte ou le logiciel de traitement d'images de votre choix pour compl\u00e9ter facilement les informations (date, lieux...).","title":"RESSOURCES"},{"location":"03-ressources/#ressources","text":"","title":"RESSOURCES"},{"location":"03-ressources/#logos","text":"remarques : les versions 2023 sont en cours de cr\u00e9ation Pour la communication ou pour cr\u00e9er des autocollants, des t-shirts, des tasses... NDC : png - svg Scratch : png - svg Python : png - svg Scratch & Python : png - svg","title":"LOGOS"},{"location":"03-ressources/#affiches","text":"remarques : les versions 2023 sont en cours de cr\u00e9ation Plusieurs versions sont propos\u00e9es: portrait 7000x10000 pixels (6,7 Mo) portrait 3500x5000 pixels (2 Mo) portrait 1750x2500 pixels (628 ko) paysage 10000x7000 pixels (6 Mo) paysage 5000x3500 pixels (1,8 ko) paysage 2500x1750 pixels (560 ko) En pla\u00e7ant l'image en fond de page, vous pouvez utiliser le logiciel de traitement de texte ou le logiciel de traitement d'images de votre choix pour compl\u00e9ter facilement les informations (date, lieux...).","title":"AFFICHES"},{"location":"PYTHON/01-presentation/","text":"INTRODUCTION Pyxel est un moteur de jeu vid\u00e9o r\u00e9tro pour Python. Gr\u00e2ce \u00e0 ses sp\u00e9cifications simples inspir\u00e9es par les consoles r\u00e9tro, comme le fait que seulement 16 couleurs peuvent \u00eatre affich\u00e9es et que seulement 4 sons peuvent \u00eatre lus en m\u00eame temps, vous pouvez vous sentir libre de cr\u00e9er des jeux vid\u00e9o dans le style pixel art. Les sp\u00e9cifications et les API de Pyxel sont inspir\u00e9es de PICO-8 et TIC-80. Pyxel est un logiciel libre et open source.\" Extrait de github.com/kitao/pyxel","title":"INTRODUCTION"},{"location":"PYTHON/01-presentation/#introduction","text":"Pyxel est un moteur de jeu vid\u00e9o r\u00e9tro pour Python. Gr\u00e2ce \u00e0 ses sp\u00e9cifications simples inspir\u00e9es par les consoles r\u00e9tro, comme le fait que seulement 16 couleurs peuvent \u00eatre affich\u00e9es et que seulement 4 sons peuvent \u00eatre lus en m\u00eame temps, vous pouvez vous sentir libre de cr\u00e9er des jeux vid\u00e9o dans le style pixel art. Les sp\u00e9cifications et les API de Pyxel sont inspir\u00e9es de PICO-8 et TIC-80. Pyxel est un logiciel libre et open source.\" Extrait de github.com/kitao/pyxel","title":"INTRODUCTION"},{"location":"PYTHON/02-installation/","text":"INSTALLATION Voir la section \" Comment installer\" sur la page de Pyxel . Pour Windows: T\u00e9l\u00e9charger Edupyter 38 1.1 sur www.edupyter.net Installer Edupyter 38 1.1 Edupyter est portable et ne n\u00e9cessite pas de droits administrateur. Edupyter peut \u00eatre install\u00e9 dans un dossier sur le disque dur ou sur une cl\u00e9 USB / disque amovible. L'installation ne fait que copier des fichiers et des dossiers dans le dossier d'installation choisi. Le syst\u00e8me n'est pas modifi\u00e9. Pour supprimer Edupyter il suffit de supprimer le dossier dans lequel il a \u00e9t\u00e9 install\u00e9. Lancer Edupyter et cliquer sur l'ic\u00f4ne qui appara\u00eet \u00e0 c\u00f4t\u00e9 de l'horloge (voir aide ). Ouvrir Thonny Saisir le code et enregistrer le fichier Python (en .py). Ex\u00e9cuter le code en cliquant sur la touche F5 ou le bouton vert. Cette action ouvrira automatiquement la fen\u00eatre du jeu.","title":"INSTALLATION"},{"location":"PYTHON/02-installation/#installation","text":"Voir la section \" Comment installer\" sur la page de Pyxel . Pour Windows: T\u00e9l\u00e9charger Edupyter 38 1.1 sur www.edupyter.net Installer Edupyter 38 1.1 Edupyter est portable et ne n\u00e9cessite pas de droits administrateur. Edupyter peut \u00eatre install\u00e9 dans un dossier sur le disque dur ou sur une cl\u00e9 USB / disque amovible. L'installation ne fait que copier des fichiers et des dossiers dans le dossier d'installation choisi. Le syst\u00e8me n'est pas modifi\u00e9. Pour supprimer Edupyter il suffit de supprimer le dossier dans lequel il a \u00e9t\u00e9 install\u00e9. Lancer Edupyter et cliquer sur l'ic\u00f4ne qui appara\u00eet \u00e0 c\u00f4t\u00e9 de l'horloge (voir aide ). Ouvrir Thonny Saisir le code et enregistrer le fichier Python (en .py). Ex\u00e9cuter le code en cliquant sur la touche F5 ou le bouton vert. Cette action ouvrira automatiquement la fen\u00eatre du jeu.","title":"INSTALLATION"},{"location":"PYTHON/Premiers%20pas%20avec%20Pyxel%20-%20Premi%C3%A8re%20et%20Terminale/Tutoriel-01/","text":"TUTORIEL #01 - D\u00e9placer un carr\u00e9 avec les touches de directions But : d\u00e9placer un carr\u00e9 avec les touches de directions 1. Premi\u00e8re Programmation imp\u00e9rative : utilisation obligatoire de variables globales dans update . import pyxel # taille de la fenetre 128x128 pixels # ne pas modifier pyxel . init ( 128 , 128 , title = \"Nuit du c0de\" ) # position initiale du vaisseau # (origine des positions : coin haut gauche) vaisseau_x = 60 vaisseau_y = 60 def vaisseau_deplacement ( x , y ): \"\"\"d\u00e9placement avec les touches de directions\"\"\" if pyxel . btn ( pyxel . KEY_RIGHT ): if ( x < 120 ) : x = x + 1 if pyxel . btn ( pyxel . KEY_LEFT ): if ( x > 0 ) : x = x - 1 if pyxel . btn ( pyxel . KEY_DOWN ): if ( y < 120 ) : y = y + 1 if pyxel . btn ( pyxel . KEY_UP ): if ( y > 0 ) : y = y - 1 return x , y # ========================================================= # == UPDATE # ========================================================= def update (): \"\"\"mise \u00e0 jour des variables (30 fois par seconde)\"\"\" global vaisseau_x , vaisseau_y # mise \u00e0 jour de la position du vaisseau vaisseau_x , vaisseau_y = vaisseau_deplacement ( vaisseau_x , vaisseau_y ) # ========================================================= # == DRAW # ========================================================= def draw (): \"\"\"cr\u00e9ation des objets (30 fois par seconde)\"\"\" # vide la fenetre pyxel . cls ( 0 ) # vaisseau (carre 8x8) pyxel . rect ( vaisseau_x , vaisseau_y , 8 , 8 , 1 ) pyxel . run ( update , draw ) 2. Terminale Programmation orient\u00e9e objet import pyxel class Jeu : def __init__ ( self ): # taille de la fenetre 128x128 pixels # ne pas modifier pyxel . init ( 128 , 128 , title = \"Nuit du c0de\" ) # position initiale du vaisseau # (origine des positions : coin haut gauche) self . vaisseau_x = 60 self . vaisseau_y = 60 pyxel . run ( self . update , self . draw ) def vaisseau_deplacement ( self ): \"\"\"d\u00e9placement avec les touches de directions\"\"\" if pyxel . btn ( pyxel . KEY_RIGHT ) and self . vaisseau_x < 120 : self . vaisseau_x += 1 if pyxel . btn ( pyxel . KEY_LEFT ) and self . vaisseau_x > 0 : self . vaisseau_x += - 1 if pyxel . btn ( pyxel . KEY_DOWN ) and self . vaisseau_y < 120 : self . vaisseau_y += 1 if pyxel . btn ( pyxel . KEY_UP ) and self . vaisseau_y > 0 : self . vaisseau_y += - 1 # ===================================================== # == UPDATE # ===================================================== def update ( self ): \"\"\"mise \u00e0 jour des variables (30 fois par seconde)\"\"\" # deplacement du vaisseau self . vaisseau_deplacement () # ===================================================== # == DRAW # ===================================================== def draw ( self ): \"\"\"cr\u00e9ation et positionnement des objets (30 fois par seconde)\"\"\" # vide la fenetre pyxel . cls ( 0 ) # vaisseau (carre 8x8) pyxel . rect ( self . vaisseau_x , self . vaisseau_y , 8 , 8 , 1 ) Jeu () Auteur : Laurent Abbal - GitHub | Twitter","title":"TUTORIEL #01 - D\u00e9placer un carr\u00e9 avec les touches de directions"},{"location":"PYTHON/Premiers%20pas%20avec%20Pyxel%20-%20Premi%C3%A8re%20et%20Terminale/Tutoriel-01/#tutoriel-01-deplacer-un-carre-avec-les-touches-de-directions","text":"But : d\u00e9placer un carr\u00e9 avec les touches de directions","title":"TUTORIEL #01 - D\u00e9placer un carr\u00e9 avec les touches de directions"},{"location":"PYTHON/Premiers%20pas%20avec%20Pyxel%20-%20Premi%C3%A8re%20et%20Terminale/Tutoriel-01/#1-premiere","text":"Programmation imp\u00e9rative : utilisation obligatoire de variables globales dans update . import pyxel # taille de la fenetre 128x128 pixels # ne pas modifier pyxel . init ( 128 , 128 , title = \"Nuit du c0de\" ) # position initiale du vaisseau # (origine des positions : coin haut gauche) vaisseau_x = 60 vaisseau_y = 60 def vaisseau_deplacement ( x , y ): \"\"\"d\u00e9placement avec les touches de directions\"\"\" if pyxel . btn ( pyxel . KEY_RIGHT ): if ( x < 120 ) : x = x + 1 if pyxel . btn ( pyxel . KEY_LEFT ): if ( x > 0 ) : x = x - 1 if pyxel . btn ( pyxel . KEY_DOWN ): if ( y < 120 ) : y = y + 1 if pyxel . btn ( pyxel . KEY_UP ): if ( y > 0 ) : y = y - 1 return x , y # ========================================================= # == UPDATE # ========================================================= def update (): \"\"\"mise \u00e0 jour des variables (30 fois par seconde)\"\"\" global vaisseau_x , vaisseau_y # mise \u00e0 jour de la position du vaisseau vaisseau_x , vaisseau_y = vaisseau_deplacement ( vaisseau_x , vaisseau_y ) # ========================================================= # == DRAW # ========================================================= def draw (): \"\"\"cr\u00e9ation des objets (30 fois par seconde)\"\"\" # vide la fenetre pyxel . cls ( 0 ) # vaisseau (carre 8x8) pyxel . rect ( vaisseau_x , vaisseau_y , 8 , 8 , 1 ) pyxel . run ( update , draw )","title":"1. Premi\u00e8re"},{"location":"PYTHON/Premiers%20pas%20avec%20Pyxel%20-%20Premi%C3%A8re%20et%20Terminale/Tutoriel-01/#2-terminale","text":"Programmation orient\u00e9e objet import pyxel class Jeu : def __init__ ( self ): # taille de la fenetre 128x128 pixels # ne pas modifier pyxel . init ( 128 , 128 , title = \"Nuit du c0de\" ) # position initiale du vaisseau # (origine des positions : coin haut gauche) self . vaisseau_x = 60 self . vaisseau_y = 60 pyxel . run ( self . update , self . draw ) def vaisseau_deplacement ( self ): \"\"\"d\u00e9placement avec les touches de directions\"\"\" if pyxel . btn ( pyxel . KEY_RIGHT ) and self . vaisseau_x < 120 : self . vaisseau_x += 1 if pyxel . btn ( pyxel . KEY_LEFT ) and self . vaisseau_x > 0 : self . vaisseau_x += - 1 if pyxel . btn ( pyxel . KEY_DOWN ) and self . vaisseau_y < 120 : self . vaisseau_y += 1 if pyxel . btn ( pyxel . KEY_UP ) and self . vaisseau_y > 0 : self . vaisseau_y += - 1 # ===================================================== # == UPDATE # ===================================================== def update ( self ): \"\"\"mise \u00e0 jour des variables (30 fois par seconde)\"\"\" # deplacement du vaisseau self . vaisseau_deplacement () # ===================================================== # == DRAW # ===================================================== def draw ( self ): \"\"\"cr\u00e9ation et positionnement des objets (30 fois par seconde)\"\"\" # vide la fenetre pyxel . cls ( 0 ) # vaisseau (carre 8x8) pyxel . rect ( self . vaisseau_x , self . vaisseau_y , 8 , 8 , 1 ) Jeu () Auteur : Laurent Abbal - GitHub | Twitter","title":"2. Terminale"},{"location":"PYTHON/Premiers%20pas%20avec%20Pyxel%20-%20Premi%C3%A8re%20et%20Terminale/Tutoriel-02/","text":"TUTORIEL #02 - Ajouter des tirs But : ajouter des tirs 1. Premi\u00e8re Programmation imp\u00e9rative : utilisation obligatoire de variables globales dans update . import pyxel # taille de la fenetre 128x128 pixels # ne pas modifier pyxel . init ( 128 , 128 , title = \"Nuit du c0de\" ) # position initiale du vaisseau # (origine des positions : coin haut gauche) vaisseau_x = 60 vaisseau_y = 60 # initialisation des tirs tirs_liste = [] def vaisseau_deplacement ( x , y ): \"\"\"d\u00e9placement avec les touches de directions\"\"\" if pyxel . btn ( pyxel . KEY_RIGHT ): if ( x < 120 ) : x = x + 1 if pyxel . btn ( pyxel . KEY_LEFT ): if ( x > 0 ) : x = x - 1 if pyxel . btn ( pyxel . KEY_DOWN ): if ( y < 120 ) : y = y + 1 if pyxel . btn ( pyxel . KEY_UP ): if ( y > 0 ) : y = y - 1 return x , y def tirs_creation ( x , y , tirs_liste ): \"\"\"cr\u00e9ation d'un tir avec la barre d'espace\"\"\" # btnr pour eviter les tirs multiples if pyxel . btnr ( pyxel . KEY_SPACE ): tirs_liste . append ([ x + 4 , y - 4 ]) return tirs_liste def tirs_deplacement ( tirs_liste ): \"\"\"d\u00e9placement des tirs vers le haut et suppression s'ils sortent du cadre\"\"\" for tir in tirs_liste : tir [ 1 ] -= 1 if tir [ 1 ] <- 8 : tirs_liste . remove ( tir ) return tirs_liste # ========================================================= # == UPDATE # ========================================================= def update (): \"\"\"mise \u00e0 jour des variables (30 fois par seconde)\"\"\" global vaisseau_x , vaisseau_y , tirs_liste # mise \u00e0 jour de la position du vaisseau vaisseau_x , vaisseau_y = vaisseau_deplacement ( vaisseau_x , vaisseau_y ) # creation des tirs en fonction de la position du vaisseau tirs_liste = tirs_creation ( vaisseau_x , vaisseau_y , tirs_liste ) # mise a jour des positions des tirs tirs_liste = tirs_deplacement ( tirs_liste ) # ========================================================= # == DRAW # ========================================================= def draw (): \"\"\"cr\u00e9ation des objets (30 fois par seconde)\"\"\" # vide la fenetre pyxel . cls ( 0 ) # vaisseau (carre 8x8) pyxel . rect ( vaisseau_x , vaisseau_y , 8 , 8 , 1 ) # tirs for tir in tirs_liste : pyxel . rect ( tir [ 0 ], tir [ 1 ], 1 , 4 , 10 ) pyxel . run ( update , draw ) 2. Terminale Programmation orient\u00e9e objet import pyxel class Jeu : def __init__ ( self ): # taille de la fenetre 128x128 pixels # ne pas modifier pyxel . init ( 128 , 128 , title = \"Nuit du c0de\" ) # position initiale du vaisseau # (origine des positions : coin haut gauche) self . vaisseau_x = 60 self . vaisseau_y = 60 # initialisation des tirs self . tirs_liste = [] pyxel . run ( self . update , self . draw ) def vaisseau_deplacement ( self ): \"\"\"d\u00e9placement avec les touches de directions\"\"\" if pyxel . btn ( pyxel . KEY_RIGHT ) and self . vaisseau_x < 120 : self . vaisseau_x += 1 if pyxel . btn ( pyxel . KEY_LEFT ) and self . vaisseau_x > 0 : self . vaisseau_x += - 1 if pyxel . btn ( pyxel . KEY_DOWN ) and self . vaisseau_y < 120 : self . vaisseau_y += 1 if pyxel . btn ( pyxel . KEY_UP ) and self . vaisseau_y > 0 : self . vaisseau_y += - 1 def tirs_creation ( self ): \"\"\"cr\u00e9ation d'un tir avec la barre d'espace\"\"\" if pyxel . btnr ( pyxel . KEY_SPACE ): self . tirs_liste . append ([ self . vaisseau_x + 4 , self . vaisseau_y - 4 ]) def tirs_deplacement ( self ): \"\"\"d\u00e9placement des tirs vers le haut et suppression s'ils sortent du cadre\"\"\" for tir in self . tirs_liste : tir [ 1 ] -= 1 if tir [ 1 ] <- 8 : self . tirs_liste . remove ( tir ) # ===================================================== # == UPDATE # ===================================================== def update ( self ): \"\"\"mise \u00e0 jour des variables (30 fois par seconde)\"\"\" # deplacement du vaisseau self . vaisseau_deplacement () # creation des tirs en fonction de la position du vaisseau self . tirs_creation () # mise a jour des positions des tirs self . tirs_deplacement () # ===================================================== # == DRAW # ===================================================== def draw ( self ): \"\"\"cr\u00e9ation et positionnement des objets (30 fois par seconde)\"\"\" # vide la fenetre pyxel . cls ( 0 ) # vaisseau (carre 8x8) pyxel . rect ( self . vaisseau_x , self . vaisseau_y , 8 , 8 , 1 ) # tirs for tir in self . tirs_liste : pyxel . rect ( tir [ 0 ], tir [ 1 ], 1 , 4 , 10 ) Jeu () Auteur : Laurent Abbal - GitHub | Twitter","title":"TUTORIEL #02 - Ajouter des tirs"},{"location":"PYTHON/Premiers%20pas%20avec%20Pyxel%20-%20Premi%C3%A8re%20et%20Terminale/Tutoriel-02/#tutoriel-02-ajouter-des-tirs","text":"But : ajouter des tirs","title":"TUTORIEL #02 - Ajouter des tirs"},{"location":"PYTHON/Premiers%20pas%20avec%20Pyxel%20-%20Premi%C3%A8re%20et%20Terminale/Tutoriel-02/#1-premiere","text":"Programmation imp\u00e9rative : utilisation obligatoire de variables globales dans update . import pyxel # taille de la fenetre 128x128 pixels # ne pas modifier pyxel . init ( 128 , 128 , title = \"Nuit du c0de\" ) # position initiale du vaisseau # (origine des positions : coin haut gauche) vaisseau_x = 60 vaisseau_y = 60 # initialisation des tirs tirs_liste = [] def vaisseau_deplacement ( x , y ): \"\"\"d\u00e9placement avec les touches de directions\"\"\" if pyxel . btn ( pyxel . KEY_RIGHT ): if ( x < 120 ) : x = x + 1 if pyxel . btn ( pyxel . KEY_LEFT ): if ( x > 0 ) : x = x - 1 if pyxel . btn ( pyxel . KEY_DOWN ): if ( y < 120 ) : y = y + 1 if pyxel . btn ( pyxel . KEY_UP ): if ( y > 0 ) : y = y - 1 return x , y def tirs_creation ( x , y , tirs_liste ): \"\"\"cr\u00e9ation d'un tir avec la barre d'espace\"\"\" # btnr pour eviter les tirs multiples if pyxel . btnr ( pyxel . KEY_SPACE ): tirs_liste . append ([ x + 4 , y - 4 ]) return tirs_liste def tirs_deplacement ( tirs_liste ): \"\"\"d\u00e9placement des tirs vers le haut et suppression s'ils sortent du cadre\"\"\" for tir in tirs_liste : tir [ 1 ] -= 1 if tir [ 1 ] <- 8 : tirs_liste . remove ( tir ) return tirs_liste # ========================================================= # == UPDATE # ========================================================= def update (): \"\"\"mise \u00e0 jour des variables (30 fois par seconde)\"\"\" global vaisseau_x , vaisseau_y , tirs_liste # mise \u00e0 jour de la position du vaisseau vaisseau_x , vaisseau_y = vaisseau_deplacement ( vaisseau_x , vaisseau_y ) # creation des tirs en fonction de la position du vaisseau tirs_liste = tirs_creation ( vaisseau_x , vaisseau_y , tirs_liste ) # mise a jour des positions des tirs tirs_liste = tirs_deplacement ( tirs_liste ) # ========================================================= # == DRAW # ========================================================= def draw (): \"\"\"cr\u00e9ation des objets (30 fois par seconde)\"\"\" # vide la fenetre pyxel . cls ( 0 ) # vaisseau (carre 8x8) pyxel . rect ( vaisseau_x , vaisseau_y , 8 , 8 , 1 ) # tirs for tir in tirs_liste : pyxel . rect ( tir [ 0 ], tir [ 1 ], 1 , 4 , 10 ) pyxel . run ( update , draw )","title":"1. Premi\u00e8re"},{"location":"PYTHON/Premiers%20pas%20avec%20Pyxel%20-%20Premi%C3%A8re%20et%20Terminale/Tutoriel-02/#2-terminale","text":"Programmation orient\u00e9e objet import pyxel class Jeu : def __init__ ( self ): # taille de la fenetre 128x128 pixels # ne pas modifier pyxel . init ( 128 , 128 , title = \"Nuit du c0de\" ) # position initiale du vaisseau # (origine des positions : coin haut gauche) self . vaisseau_x = 60 self . vaisseau_y = 60 # initialisation des tirs self . tirs_liste = [] pyxel . run ( self . update , self . draw ) def vaisseau_deplacement ( self ): \"\"\"d\u00e9placement avec les touches de directions\"\"\" if pyxel . btn ( pyxel . KEY_RIGHT ) and self . vaisseau_x < 120 : self . vaisseau_x += 1 if pyxel . btn ( pyxel . KEY_LEFT ) and self . vaisseau_x > 0 : self . vaisseau_x += - 1 if pyxel . btn ( pyxel . KEY_DOWN ) and self . vaisseau_y < 120 : self . vaisseau_y += 1 if pyxel . btn ( pyxel . KEY_UP ) and self . vaisseau_y > 0 : self . vaisseau_y += - 1 def tirs_creation ( self ): \"\"\"cr\u00e9ation d'un tir avec la barre d'espace\"\"\" if pyxel . btnr ( pyxel . KEY_SPACE ): self . tirs_liste . append ([ self . vaisseau_x + 4 , self . vaisseau_y - 4 ]) def tirs_deplacement ( self ): \"\"\"d\u00e9placement des tirs vers le haut et suppression s'ils sortent du cadre\"\"\" for tir in self . tirs_liste : tir [ 1 ] -= 1 if tir [ 1 ] <- 8 : self . tirs_liste . remove ( tir ) # ===================================================== # == UPDATE # ===================================================== def update ( self ): \"\"\"mise \u00e0 jour des variables (30 fois par seconde)\"\"\" # deplacement du vaisseau self . vaisseau_deplacement () # creation des tirs en fonction de la position du vaisseau self . tirs_creation () # mise a jour des positions des tirs self . tirs_deplacement () # ===================================================== # == DRAW # ===================================================== def draw ( self ): \"\"\"cr\u00e9ation et positionnement des objets (30 fois par seconde)\"\"\" # vide la fenetre pyxel . cls ( 0 ) # vaisseau (carre 8x8) pyxel . rect ( self . vaisseau_x , self . vaisseau_y , 8 , 8 , 1 ) # tirs for tir in self . tirs_liste : pyxel . rect ( tir [ 0 ], tir [ 1 ], 1 , 4 , 10 ) Jeu () Auteur : Laurent Abbal - GitHub | Twitter","title":"2. Terminale"},{"location":"PYTHON/Premiers%20pas%20avec%20Pyxel%20-%20Premi%C3%A8re%20et%20Terminale/Tutoriel-03/","text":"TUTORIEL #03 - Ajouter des ennemis But : ajouter des ennemis 1. Premi\u00e8re Programmation imp\u00e9rative : utilisation obligatoire de variables globales dans update . # on rajoute random import pyxel , random # taille de la fenetre 128x128 pixels # ne pas modifier pyxel . init ( 128 , 128 , title = \"Nuit du c0de\" ) # position initiale du vaisseau # (origine des positions : coin haut gauche) vaisseau_x = 60 vaisseau_y = 60 # initialisation des tirs tirs_liste = [] # initialisation des ennemis ennemis_liste = [] def vaisseau_deplacement ( x , y ): \"\"\"d\u00e9placement avec les touches de directions\"\"\" if pyxel . btn ( pyxel . KEY_RIGHT ): if ( x < 120 ) : x = x + 1 if pyxel . btn ( pyxel . KEY_LEFT ): if ( x > 0 ) : x = x - 1 if pyxel . btn ( pyxel . KEY_DOWN ): if ( y < 120 ) : y = y + 1 if pyxel . btn ( pyxel . KEY_UP ): if ( y > 0 ) : y = y - 1 return x , y def tirs_creation ( x , y , tirs_liste ): \"\"\"cr\u00e9ation d'un tir avec la barre d'espace\"\"\" # btnr pour eviter les tirs multiples if pyxel . btnr ( pyxel . KEY_SPACE ): tirs_liste . append ([ x + 4 , y - 4 ]) return tirs_liste def tirs_deplacement ( tirs_liste ): \"\"\"d\u00e9placement des tirs vers le haut et suppression s'ils sortent du cadre\"\"\" for tir in tirs_liste : tir [ 1 ] -= 1 if tir [ 1 ] <- 8 : tirs_liste . remove ( tir ) return tirs_liste def ennemis_creation ( ennemis_liste ): \"\"\"cr\u00e9ation al\u00e9atoire des ennemis\"\"\" # un ennemi par seconde if ( pyxel . frame_count % 30 == 0 ): ennemis_liste . append ([ random . randint ( 0 , 120 ), 0 ]) return ennemis_liste def ennemis_deplacement ( ennemis_liste ): \"\"\"d\u00e9placement des ennemis vers le haut et suppression s'ils sortent du cadre\"\"\" for ennemi in ennemis_liste : ennemi [ 1 ] += 1 if ennemi [ 1 ] > 128 : ennemis_liste . remove ( ennemi ) return ennemis_liste # ========================================================= # == UPDATE # ========================================================= def update (): \"\"\"mise \u00e0 jour des variables (30 fois par seconde)\"\"\" global vaisseau_x , vaisseau_y , tirs_liste , ennemis_liste # mise \u00e0 jour de la position du vaisseau vaisseau_x , vaisseau_y = vaisseau_deplacement ( vaisseau_x , vaisseau_y ) # creation des tirs en fonction de la position du vaisseau tirs_liste = tirs_creation ( vaisseau_x , vaisseau_y , tirs_liste ) # mise a jour des positions des tirs tirs_liste = tirs_deplacement ( tirs_liste ) # creation des ennemis ennemis_liste = ennemis_creation ( ennemis_liste ) # mise a jour des positions des ennemis ennemis_liste = ennemis_deplacement ( ennemis_liste ) # ========================================================= # == DRAW # ========================================================= def draw (): \"\"\"cr\u00e9ation des objets (30 fois par seconde)\"\"\" # vide la fenetre pyxel . cls ( 0 ) # vaisseau (carre 8x8) pyxel . rect ( vaisseau_x , vaisseau_y , 8 , 8 , 1 ) # tirs for tir in tirs_liste : pyxel . rect ( tir [ 0 ], tir [ 1 ], 1 , 4 , 10 ) # ennemis for ennemi in ennemis_liste : pyxel . rect ( ennemi [ 0 ], ennemi [ 1 ], 8 , 8 , 8 ) pyxel . run ( update , draw ) 2. Terminale Programmation orient\u00e9e objet # on rajoute random import pyxel , random class Jeu : def __init__ ( self ): # taille de la fenetre 128x128 pixels # ne pas modifier pyxel . init ( 128 , 128 , title = \"Nuit du c0de\" ) # position initiale du vaisseau # (origine des positions : coin haut gauche) self . vaisseau_x = 60 self . vaisseau_y = 60 # initialisation des tirs self . tirs_liste = [] # initialisation des ennemis self . ennemis_liste = [] pyxel . run ( self . update , self . draw ) def deplacement ( self ): \"\"\"d\u00e9placement avec les touches de directions\"\"\" if pyxel . btn ( pyxel . KEY_RIGHT ) and self . vaisseau_x < 120 : self . vaisseau_x += 1 if pyxel . btn ( pyxel . KEY_LEFT ) and self . vaisseau_x > 0 : self . vaisseau_x += - 1 if pyxel . btn ( pyxel . KEY_DOWN ) and self . vaisseau_y < 120 : self . vaisseau_y += 1 if pyxel . btn ( pyxel . KEY_UP ) and self . vaisseau_y > 0 : self . vaisseau_y += - 1 def tirs_creation ( self ): \"\"\"cr\u00e9ation d'un tir avec la barre d'espace\"\"\" if pyxel . btnr ( pyxel . KEY_SPACE ): self . tirs_liste . append ([ self . vaisseau_x + 4 , self . vaisseau_y - 4 ]) def tirs_deplacement ( self ): \"\"\"d\u00e9placement des tirs vers le haut et suppression quand ils sortent du cadre\"\"\" for tir in self . tirs_liste : tir [ 1 ] -= 1 if tir [ 1 ] <- 8 : self . tirs_liste . remove ( tir ) def ennemis_creation ( self ): \"\"\"cr\u00e9ation al\u00e9atoire des ennemis\"\"\" # un ennemi par seconde if ( pyxel . frame_count % 30 == 0 ): self . ennemis_liste . append ([ random . randint ( 0 , 120 ), 0 ]) def ennemis_deplacement ( self ): \"\"\"d\u00e9placement des ennemis vers le haut et suppression s'ils sortent du cadre\"\"\" for ennemi in self . ennemis_liste : ennemi [ 1 ] += 1 if ennemi [ 1 ] > 128 : self . ennemis_liste . remove ( ennemi ) # ===================================================== # == UPDATE # ===================================================== def update ( self ): \"\"\"mise \u00e0 jour des variables (30 fois par seconde)\"\"\" # deplacement du vaisseau self . deplacement () # creation des tirs en fonction de la position du vaisseau self . tirs_creation () # mise a jour des positions des tirs self . tirs_deplacement () # creation des ennemis self . ennemis_creation () # mise a jour des positions des ennemis self . ennemis_deplacement () # ===================================================== # == DRAW # ===================================================== def draw ( self ): \"\"\"cr\u00e9ation et positionnement des objets (30 fois par seconde)\"\"\" # vide la fenetre pyxel . cls ( 0 ) # vaisseau (carre 8x8) pyxel . rect ( self . vaisseau_x , self . vaisseau_y , 8 , 8 , 1 ) # tirs for tir in self . tirs_liste : pyxel . rect ( tir [ 0 ], tir [ 1 ], 1 , 4 , 10 ) # ennemis for ennemi in self . ennemis_liste : pyxel . rect ( ennemi [ 0 ], ennemi [ 1 ], 8 , 8 , 8 ) Jeu () Auteur : Laurent Abbal - GitHub | Twitter","title":"TUTORIEL #03 - Ajouter des ennemis"},{"location":"PYTHON/Premiers%20pas%20avec%20Pyxel%20-%20Premi%C3%A8re%20et%20Terminale/Tutoriel-03/#tutoriel-03-ajouter-des-ennemis","text":"But : ajouter des ennemis","title":"TUTORIEL #03 - Ajouter des ennemis"},{"location":"PYTHON/Premiers%20pas%20avec%20Pyxel%20-%20Premi%C3%A8re%20et%20Terminale/Tutoriel-03/#1-premiere","text":"Programmation imp\u00e9rative : utilisation obligatoire de variables globales dans update . # on rajoute random import pyxel , random # taille de la fenetre 128x128 pixels # ne pas modifier pyxel . init ( 128 , 128 , title = \"Nuit du c0de\" ) # position initiale du vaisseau # (origine des positions : coin haut gauche) vaisseau_x = 60 vaisseau_y = 60 # initialisation des tirs tirs_liste = [] # initialisation des ennemis ennemis_liste = [] def vaisseau_deplacement ( x , y ): \"\"\"d\u00e9placement avec les touches de directions\"\"\" if pyxel . btn ( pyxel . KEY_RIGHT ): if ( x < 120 ) : x = x + 1 if pyxel . btn ( pyxel . KEY_LEFT ): if ( x > 0 ) : x = x - 1 if pyxel . btn ( pyxel . KEY_DOWN ): if ( y < 120 ) : y = y + 1 if pyxel . btn ( pyxel . KEY_UP ): if ( y > 0 ) : y = y - 1 return x , y def tirs_creation ( x , y , tirs_liste ): \"\"\"cr\u00e9ation d'un tir avec la barre d'espace\"\"\" # btnr pour eviter les tirs multiples if pyxel . btnr ( pyxel . KEY_SPACE ): tirs_liste . append ([ x + 4 , y - 4 ]) return tirs_liste def tirs_deplacement ( tirs_liste ): \"\"\"d\u00e9placement des tirs vers le haut et suppression s'ils sortent du cadre\"\"\" for tir in tirs_liste : tir [ 1 ] -= 1 if tir [ 1 ] <- 8 : tirs_liste . remove ( tir ) return tirs_liste def ennemis_creation ( ennemis_liste ): \"\"\"cr\u00e9ation al\u00e9atoire des ennemis\"\"\" # un ennemi par seconde if ( pyxel . frame_count % 30 == 0 ): ennemis_liste . append ([ random . randint ( 0 , 120 ), 0 ]) return ennemis_liste def ennemis_deplacement ( ennemis_liste ): \"\"\"d\u00e9placement des ennemis vers le haut et suppression s'ils sortent du cadre\"\"\" for ennemi in ennemis_liste : ennemi [ 1 ] += 1 if ennemi [ 1 ] > 128 : ennemis_liste . remove ( ennemi ) return ennemis_liste # ========================================================= # == UPDATE # ========================================================= def update (): \"\"\"mise \u00e0 jour des variables (30 fois par seconde)\"\"\" global vaisseau_x , vaisseau_y , tirs_liste , ennemis_liste # mise \u00e0 jour de la position du vaisseau vaisseau_x , vaisseau_y = vaisseau_deplacement ( vaisseau_x , vaisseau_y ) # creation des tirs en fonction de la position du vaisseau tirs_liste = tirs_creation ( vaisseau_x , vaisseau_y , tirs_liste ) # mise a jour des positions des tirs tirs_liste = tirs_deplacement ( tirs_liste ) # creation des ennemis ennemis_liste = ennemis_creation ( ennemis_liste ) # mise a jour des positions des ennemis ennemis_liste = ennemis_deplacement ( ennemis_liste ) # ========================================================= # == DRAW # ========================================================= def draw (): \"\"\"cr\u00e9ation des objets (30 fois par seconde)\"\"\" # vide la fenetre pyxel . cls ( 0 ) # vaisseau (carre 8x8) pyxel . rect ( vaisseau_x , vaisseau_y , 8 , 8 , 1 ) # tirs for tir in tirs_liste : pyxel . rect ( tir [ 0 ], tir [ 1 ], 1 , 4 , 10 ) # ennemis for ennemi in ennemis_liste : pyxel . rect ( ennemi [ 0 ], ennemi [ 1 ], 8 , 8 , 8 ) pyxel . run ( update , draw )","title":"1. Premi\u00e8re"},{"location":"PYTHON/Premiers%20pas%20avec%20Pyxel%20-%20Premi%C3%A8re%20et%20Terminale/Tutoriel-03/#2-terminale","text":"Programmation orient\u00e9e objet # on rajoute random import pyxel , random class Jeu : def __init__ ( self ): # taille de la fenetre 128x128 pixels # ne pas modifier pyxel . init ( 128 , 128 , title = \"Nuit du c0de\" ) # position initiale du vaisseau # (origine des positions : coin haut gauche) self . vaisseau_x = 60 self . vaisseau_y = 60 # initialisation des tirs self . tirs_liste = [] # initialisation des ennemis self . ennemis_liste = [] pyxel . run ( self . update , self . draw ) def deplacement ( self ): \"\"\"d\u00e9placement avec les touches de directions\"\"\" if pyxel . btn ( pyxel . KEY_RIGHT ) and self . vaisseau_x < 120 : self . vaisseau_x += 1 if pyxel . btn ( pyxel . KEY_LEFT ) and self . vaisseau_x > 0 : self . vaisseau_x += - 1 if pyxel . btn ( pyxel . KEY_DOWN ) and self . vaisseau_y < 120 : self . vaisseau_y += 1 if pyxel . btn ( pyxel . KEY_UP ) and self . vaisseau_y > 0 : self . vaisseau_y += - 1 def tirs_creation ( self ): \"\"\"cr\u00e9ation d'un tir avec la barre d'espace\"\"\" if pyxel . btnr ( pyxel . KEY_SPACE ): self . tirs_liste . append ([ self . vaisseau_x + 4 , self . vaisseau_y - 4 ]) def tirs_deplacement ( self ): \"\"\"d\u00e9placement des tirs vers le haut et suppression quand ils sortent du cadre\"\"\" for tir in self . tirs_liste : tir [ 1 ] -= 1 if tir [ 1 ] <- 8 : self . tirs_liste . remove ( tir ) def ennemis_creation ( self ): \"\"\"cr\u00e9ation al\u00e9atoire des ennemis\"\"\" # un ennemi par seconde if ( pyxel . frame_count % 30 == 0 ): self . ennemis_liste . append ([ random . randint ( 0 , 120 ), 0 ]) def ennemis_deplacement ( self ): \"\"\"d\u00e9placement des ennemis vers le haut et suppression s'ils sortent du cadre\"\"\" for ennemi in self . ennemis_liste : ennemi [ 1 ] += 1 if ennemi [ 1 ] > 128 : self . ennemis_liste . remove ( ennemi ) # ===================================================== # == UPDATE # ===================================================== def update ( self ): \"\"\"mise \u00e0 jour des variables (30 fois par seconde)\"\"\" # deplacement du vaisseau self . deplacement () # creation des tirs en fonction de la position du vaisseau self . tirs_creation () # mise a jour des positions des tirs self . tirs_deplacement () # creation des ennemis self . ennemis_creation () # mise a jour des positions des ennemis self . ennemis_deplacement () # ===================================================== # == DRAW # ===================================================== def draw ( self ): \"\"\"cr\u00e9ation et positionnement des objets (30 fois par seconde)\"\"\" # vide la fenetre pyxel . cls ( 0 ) # vaisseau (carre 8x8) pyxel . rect ( self . vaisseau_x , self . vaisseau_y , 8 , 8 , 1 ) # tirs for tir in self . tirs_liste : pyxel . rect ( tir [ 0 ], tir [ 1 ], 1 , 4 , 10 ) # ennemis for ennemi in self . ennemis_liste : pyxel . rect ( ennemi [ 0 ], ennemi [ 1 ], 8 , 8 , 8 ) Jeu () Auteur : Laurent Abbal - GitHub | Twitter","title":"2. Terminale"},{"location":"PYTHON/Premiers%20pas%20avec%20Pyxel%20-%20Premi%C3%A8re%20et%20Terminale/Tutoriel-04/","text":"TUTORIEL #04 - Ajouter les collisions But : ajouter les collisions 1. Premi\u00e8re Programmation imp\u00e9rative : utilisation obligatoire de variables globales dans update . # on rajoute random import pyxel , random # taille de la fenetre 128x128 pixels # ne pas modifier pyxel . init ( 128 , 128 , title = \"Nuit du c0de\" ) # position initiale du vaisseau # (origine des positions : coin haut gauche) vaisseau_x = 60 vaisseau_y = 60 # vies vies = 1 # initialisation des tirs tirs_liste = [] # initialisation des ennemis ennemis_liste = [] def vaisseau_deplacement ( x , y ): \"\"\"d\u00e9placement avec les touches de directions\"\"\" if pyxel . btn ( pyxel . KEY_RIGHT ): if ( x < 120 ) : x = x + 1 if pyxel . btn ( pyxel . KEY_LEFT ): if ( x > 0 ) : x = x - 1 if pyxel . btn ( pyxel . KEY_DOWN ): if ( y < 120 ) : y = y + 1 if pyxel . btn ( pyxel . KEY_UP ): if ( y > 0 ) : y = y - 1 return x , y def tirs_creation ( x , y , tirs_liste ): \"\"\"cr\u00e9ation d'un tir avec la barre d'espace\"\"\" # btnr pour eviter les tirs multiples if pyxel . btnr ( pyxel . KEY_SPACE ): tirs_liste . append ([ x + 4 , y - 4 ]) return tirs_liste def tirs_deplacement ( tirs_liste ): \"\"\"d\u00e9placement des tirs vers le haut et suppression s'ils sortent du cadre\"\"\" for tir in tirs_liste : tir [ 1 ] -= 1 if tir [ 1 ] <- 8 : tirs_liste . remove ( tir ) return tirs_liste def ennemis_creation ( ennemis_liste ): \"\"\"cr\u00e9ation al\u00e9atoire des ennemis\"\"\" # un ennemi par seconde if ( pyxel . frame_count % 30 == 0 ): ennemis_liste . append ([ random . randint ( 0 , 120 ), 0 ]) return ennemis_liste def ennemis_deplacement ( ennemis_liste ): \"\"\"d\u00e9placement des ennemis vers le haut et suppression s'ils sortent du cadre\"\"\" for ennemi in ennemis_liste : ennemi [ 1 ] += 1 if ennemi [ 1 ] > 128 : ennemis_liste . remove ( ennemi ) return ennemis_liste def vaisseau_suppression ( vies ): \"\"\"disparition du vaisseau et d'un ennemi si contact\"\"\" for ennemi in ennemis_liste : if ennemi [ 0 ] <= vaisseau_x + 8 and ennemi [ 1 ] <= vaisseau_y + 8 and ennemi [ 0 ] + 8 >= vaisseau_x and ennemi [ 1 ] + 8 >= vaisseau_y : ennemis_liste . remove ( ennemi ) vies = 0 return vies def ennemis_suppression (): \"\"\"disparition d'un ennemi et d'un tir si contact\"\"\" for ennemi in ennemis_liste : for tir in tirs_liste : if ennemi [ 0 ] <= tir [ 0 ] + 1 and ennemi [ 0 ] + 8 >= tir [ 0 ] and ennemi [ 1 ] + 8 >= tir [ 1 ]: ennemis_liste . remove ( ennemi ) tirs_liste . remove ( tir ) # ========================================================= # == UPDATE # ========================================================= def update (): \"\"\"mise \u00e0 jour des variables (30 fois par seconde)\"\"\" global vaisseau_x , vaisseau_y , tirs_liste , ennemis_liste , vies # mise \u00e0 jour de la position du vaisseau vaisseau_x , vaisseau_y = vaisseau_deplacement ( vaisseau_x , vaisseau_y ) # creation des tirs en fonction de la position du vaisseau tirs_liste = tirs_creation ( vaisseau_x , vaisseau_y , tirs_liste ) # mise a jour des positions des tirs tirs_liste = tirs_deplacement ( tirs_liste ) # creation des ennemis ennemis_liste = ennemis_creation ( ennemis_liste ) # mise a jour des positions des ennemis ennemis_liste = ennemis_deplacement ( ennemis_liste ) # suppression des ennemis et tirs si contact ennemis_suppression () # suppression du vaisseau et ennemi si contact vies = vaisseau_suppression ( vies ) # ========================================================= # == DRAW # ========================================================= def draw (): \"\"\"cr\u00e9ation des objets (30 fois par seconde)\"\"\" # vide la fenetre pyxel . cls ( 0 ) # si le vaisseau possede des vies le jeu continue if vies > 0 : # vaisseau (carre 8x8) pyxel . rect ( vaisseau_x , vaisseau_y , 8 , 8 , 1 ) # tirs for tir in tirs_liste : pyxel . rect ( tir [ 0 ], tir [ 1 ], 1 , 4 , 10 ) # ennemis for ennemi in ennemis_liste : pyxel . rect ( ennemi [ 0 ], ennemi [ 1 ], 8 , 8 , 8 ) # sinon: GAME OVER else : pyxel . text ( 50 , 64 , 'GAME OVER' , 7 ) pyxel . run ( update , draw ) 2. Terminale Programmation orient\u00e9e objet # on rajoute random import pyxel , random class Jeu : def __init__ ( self ): # taille de la fenetre 128x128 pixels # ne pas modifier pyxel . init ( 128 , 128 , title = \"Nuit du c0de\" ) # position initiale du vaisseau # (origine des positions : coin haut gauche) self . vaisseau_x = 60 self . vaisseau_y = 60 # vies self . vies = 1 # initialisation des tirs self . tirs_liste = [] # initialisation des ennemis self . ennemis_liste = [] pyxel . run ( self . update , self . draw ) def deplacement ( self ): \"\"\"d\u00e9placement avec les touches de directions\"\"\" if pyxel . btn ( pyxel . KEY_RIGHT ) and self . vaisseau_x < 120 : self . vaisseau_x += 1 if pyxel . btn ( pyxel . KEY_LEFT ) and self . vaisseau_x > 0 : self . vaisseau_x += - 1 if pyxel . btn ( pyxel . KEY_DOWN ) and self . vaisseau_y < 120 : self . vaisseau_y += 1 if pyxel . btn ( pyxel . KEY_UP ) and self . vaisseau_y > 0 : self . vaisseau_y += - 1 def tirs_creation ( self ): \"\"\"cr\u00e9ation d'un tir avec la barre d'espace\"\"\" if pyxel . btnr ( pyxel . KEY_SPACE ): self . tirs_liste . append ([ self . vaisseau_x + 4 , self . vaisseau_y - 4 ]) def tirs_deplacement ( self ): \"\"\"d\u00e9placement des tirs vers le haut et suppression quand ils sortent du cadre\"\"\" for tir in self . tirs_liste : tir [ 1 ] -= 1 if tir [ 1 ] <- 8 : self . tirs_liste . remove ( tir ) def ennemis_creation ( self ): \"\"\"cr\u00e9ation al\u00e9atoire des ennemis\"\"\" # un ennemi par seconde if ( pyxel . frame_count % 30 == 0 ): self . ennemis_liste . append ([ random . randint ( 0 , 120 ), 0 ]) def ennemis_deplacement ( self ): \"\"\"d\u00e9placement des ennemis vers le haut et suppression s'ils sortent du cadre\"\"\" for ennemi in self . ennemis_liste : ennemi [ 1 ] += 1 if ennemi [ 1 ] > 128 : self . ennemis_liste . remove ( ennemi ) def vaisseau_suppression ( self ): \"\"\"disparition du vaisseau et d'un ennemi si contact\"\"\" for ennemi in self . ennemis_liste : if ennemi [ 0 ] <= self . vaisseau_x + 8 and ennemi [ 1 ] <= self . vaisseau_y + 8 and ennemi [ 0 ] + 8 >= self . vaisseau_x and ennemi [ 1 ] + 8 >= self . vaisseau_y : self . ennemis_liste . remove ( ennemi ) self . vies = 0 def ennemis_suppression ( self ): \"\"\"disparition d'un ennemi et d'un tir si contact\"\"\" for ennemi in self . ennemis_liste : for tir in self . tirs_liste : if ennemi [ 0 ] <= tir [ 0 ] + 1 and ennemi [ 0 ] + 8 >= tir [ 0 ] and ennemi [ 1 ] + 8 >= tir [ 1 ]: self . ennemis_liste . remove ( ennemi ) self . tirs_liste . remove ( tir ) # ===================================================== # == UPDATE # ===================================================== def update ( self ): \"\"\"mise \u00e0 jour des variables (30 fois par seconde)\"\"\" # deplacement du vaisseau self . deplacement () # creation des tirs en fonction de la position du vaisseau self . tirs_creation () # mise a jour des positions des tirs self . tirs_deplacement () # creation des ennemis self . ennemis_creation () # mise a jour des positions des ennemis self . ennemis_deplacement () # suppression des ennemis et tirs si contact self . ennemis_suppression () # suppression du vaisseau et ennemi si contact self . vaisseau_suppression () # ===================================================== # == DRAW # ===================================================== def draw ( self ): \"\"\"cr\u00e9ation et positionnement des objets (30 fois par seconde)\"\"\" # vide la fenetre pyxel . cls ( 0 ) # si le vaisseau possede des vies le jeu continue if self . vies > 0 : # vaisseau (carre 8x8) pyxel . rect ( self . vaisseau_x , self . vaisseau_y , 8 , 8 , 1 ) # tirs for tir in self . tirs_liste : pyxel . rect ( tir [ 0 ], tir [ 1 ], 1 , 4 , 10 ) # ennemis for ennemi in self . ennemis_liste : pyxel . rect ( ennemi [ 0 ], ennemi [ 1 ], 8 , 8 , 8 ) # sinon: GAME OVER else : pyxel . text ( 50 , 64 , 'GAME OVER' , 7 ) Jeu () Auteur : Laurent Abbal - GitHub | Twitter","title":"TUTORIEL #04 - Ajouter les collisions"},{"location":"PYTHON/Premiers%20pas%20avec%20Pyxel%20-%20Premi%C3%A8re%20et%20Terminale/Tutoriel-04/#tutoriel-04-ajouter-les-collisions","text":"But : ajouter les collisions","title":"TUTORIEL #04 - Ajouter les collisions"},{"location":"PYTHON/Premiers%20pas%20avec%20Pyxel%20-%20Premi%C3%A8re%20et%20Terminale/Tutoriel-04/#1-premiere","text":"Programmation imp\u00e9rative : utilisation obligatoire de variables globales dans update . # on rajoute random import pyxel , random # taille de la fenetre 128x128 pixels # ne pas modifier pyxel . init ( 128 , 128 , title = \"Nuit du c0de\" ) # position initiale du vaisseau # (origine des positions : coin haut gauche) vaisseau_x = 60 vaisseau_y = 60 # vies vies = 1 # initialisation des tirs tirs_liste = [] # initialisation des ennemis ennemis_liste = [] def vaisseau_deplacement ( x , y ): \"\"\"d\u00e9placement avec les touches de directions\"\"\" if pyxel . btn ( pyxel . KEY_RIGHT ): if ( x < 120 ) : x = x + 1 if pyxel . btn ( pyxel . KEY_LEFT ): if ( x > 0 ) : x = x - 1 if pyxel . btn ( pyxel . KEY_DOWN ): if ( y < 120 ) : y = y + 1 if pyxel . btn ( pyxel . KEY_UP ): if ( y > 0 ) : y = y - 1 return x , y def tirs_creation ( x , y , tirs_liste ): \"\"\"cr\u00e9ation d'un tir avec la barre d'espace\"\"\" # btnr pour eviter les tirs multiples if pyxel . btnr ( pyxel . KEY_SPACE ): tirs_liste . append ([ x + 4 , y - 4 ]) return tirs_liste def tirs_deplacement ( tirs_liste ): \"\"\"d\u00e9placement des tirs vers le haut et suppression s'ils sortent du cadre\"\"\" for tir in tirs_liste : tir [ 1 ] -= 1 if tir [ 1 ] <- 8 : tirs_liste . remove ( tir ) return tirs_liste def ennemis_creation ( ennemis_liste ): \"\"\"cr\u00e9ation al\u00e9atoire des ennemis\"\"\" # un ennemi par seconde if ( pyxel . frame_count % 30 == 0 ): ennemis_liste . append ([ random . randint ( 0 , 120 ), 0 ]) return ennemis_liste def ennemis_deplacement ( ennemis_liste ): \"\"\"d\u00e9placement des ennemis vers le haut et suppression s'ils sortent du cadre\"\"\" for ennemi in ennemis_liste : ennemi [ 1 ] += 1 if ennemi [ 1 ] > 128 : ennemis_liste . remove ( ennemi ) return ennemis_liste def vaisseau_suppression ( vies ): \"\"\"disparition du vaisseau et d'un ennemi si contact\"\"\" for ennemi in ennemis_liste : if ennemi [ 0 ] <= vaisseau_x + 8 and ennemi [ 1 ] <= vaisseau_y + 8 and ennemi [ 0 ] + 8 >= vaisseau_x and ennemi [ 1 ] + 8 >= vaisseau_y : ennemis_liste . remove ( ennemi ) vies = 0 return vies def ennemis_suppression (): \"\"\"disparition d'un ennemi et d'un tir si contact\"\"\" for ennemi in ennemis_liste : for tir in tirs_liste : if ennemi [ 0 ] <= tir [ 0 ] + 1 and ennemi [ 0 ] + 8 >= tir [ 0 ] and ennemi [ 1 ] + 8 >= tir [ 1 ]: ennemis_liste . remove ( ennemi ) tirs_liste . remove ( tir ) # ========================================================= # == UPDATE # ========================================================= def update (): \"\"\"mise \u00e0 jour des variables (30 fois par seconde)\"\"\" global vaisseau_x , vaisseau_y , tirs_liste , ennemis_liste , vies # mise \u00e0 jour de la position du vaisseau vaisseau_x , vaisseau_y = vaisseau_deplacement ( vaisseau_x , vaisseau_y ) # creation des tirs en fonction de la position du vaisseau tirs_liste = tirs_creation ( vaisseau_x , vaisseau_y , tirs_liste ) # mise a jour des positions des tirs tirs_liste = tirs_deplacement ( tirs_liste ) # creation des ennemis ennemis_liste = ennemis_creation ( ennemis_liste ) # mise a jour des positions des ennemis ennemis_liste = ennemis_deplacement ( ennemis_liste ) # suppression des ennemis et tirs si contact ennemis_suppression () # suppression du vaisseau et ennemi si contact vies = vaisseau_suppression ( vies ) # ========================================================= # == DRAW # ========================================================= def draw (): \"\"\"cr\u00e9ation des objets (30 fois par seconde)\"\"\" # vide la fenetre pyxel . cls ( 0 ) # si le vaisseau possede des vies le jeu continue if vies > 0 : # vaisseau (carre 8x8) pyxel . rect ( vaisseau_x , vaisseau_y , 8 , 8 , 1 ) # tirs for tir in tirs_liste : pyxel . rect ( tir [ 0 ], tir [ 1 ], 1 , 4 , 10 ) # ennemis for ennemi in ennemis_liste : pyxel . rect ( ennemi [ 0 ], ennemi [ 1 ], 8 , 8 , 8 ) # sinon: GAME OVER else : pyxel . text ( 50 , 64 , 'GAME OVER' , 7 ) pyxel . run ( update , draw )","title":"1. Premi\u00e8re"},{"location":"PYTHON/Premiers%20pas%20avec%20Pyxel%20-%20Premi%C3%A8re%20et%20Terminale/Tutoriel-04/#2-terminale","text":"Programmation orient\u00e9e objet # on rajoute random import pyxel , random class Jeu : def __init__ ( self ): # taille de la fenetre 128x128 pixels # ne pas modifier pyxel . init ( 128 , 128 , title = \"Nuit du c0de\" ) # position initiale du vaisseau # (origine des positions : coin haut gauche) self . vaisseau_x = 60 self . vaisseau_y = 60 # vies self . vies = 1 # initialisation des tirs self . tirs_liste = [] # initialisation des ennemis self . ennemis_liste = [] pyxel . run ( self . update , self . draw ) def deplacement ( self ): \"\"\"d\u00e9placement avec les touches de directions\"\"\" if pyxel . btn ( pyxel . KEY_RIGHT ) and self . vaisseau_x < 120 : self . vaisseau_x += 1 if pyxel . btn ( pyxel . KEY_LEFT ) and self . vaisseau_x > 0 : self . vaisseau_x += - 1 if pyxel . btn ( pyxel . KEY_DOWN ) and self . vaisseau_y < 120 : self . vaisseau_y += 1 if pyxel . btn ( pyxel . KEY_UP ) and self . vaisseau_y > 0 : self . vaisseau_y += - 1 def tirs_creation ( self ): \"\"\"cr\u00e9ation d'un tir avec la barre d'espace\"\"\" if pyxel . btnr ( pyxel . KEY_SPACE ): self . tirs_liste . append ([ self . vaisseau_x + 4 , self . vaisseau_y - 4 ]) def tirs_deplacement ( self ): \"\"\"d\u00e9placement des tirs vers le haut et suppression quand ils sortent du cadre\"\"\" for tir in self . tirs_liste : tir [ 1 ] -= 1 if tir [ 1 ] <- 8 : self . tirs_liste . remove ( tir ) def ennemis_creation ( self ): \"\"\"cr\u00e9ation al\u00e9atoire des ennemis\"\"\" # un ennemi par seconde if ( pyxel . frame_count % 30 == 0 ): self . ennemis_liste . append ([ random . randint ( 0 , 120 ), 0 ]) def ennemis_deplacement ( self ): \"\"\"d\u00e9placement des ennemis vers le haut et suppression s'ils sortent du cadre\"\"\" for ennemi in self . ennemis_liste : ennemi [ 1 ] += 1 if ennemi [ 1 ] > 128 : self . ennemis_liste . remove ( ennemi ) def vaisseau_suppression ( self ): \"\"\"disparition du vaisseau et d'un ennemi si contact\"\"\" for ennemi in self . ennemis_liste : if ennemi [ 0 ] <= self . vaisseau_x + 8 and ennemi [ 1 ] <= self . vaisseau_y + 8 and ennemi [ 0 ] + 8 >= self . vaisseau_x and ennemi [ 1 ] + 8 >= self . vaisseau_y : self . ennemis_liste . remove ( ennemi ) self . vies = 0 def ennemis_suppression ( self ): \"\"\"disparition d'un ennemi et d'un tir si contact\"\"\" for ennemi in self . ennemis_liste : for tir in self . tirs_liste : if ennemi [ 0 ] <= tir [ 0 ] + 1 and ennemi [ 0 ] + 8 >= tir [ 0 ] and ennemi [ 1 ] + 8 >= tir [ 1 ]: self . ennemis_liste . remove ( ennemi ) self . tirs_liste . remove ( tir ) # ===================================================== # == UPDATE # ===================================================== def update ( self ): \"\"\"mise \u00e0 jour des variables (30 fois par seconde)\"\"\" # deplacement du vaisseau self . deplacement () # creation des tirs en fonction de la position du vaisseau self . tirs_creation () # mise a jour des positions des tirs self . tirs_deplacement () # creation des ennemis self . ennemis_creation () # mise a jour des positions des ennemis self . ennemis_deplacement () # suppression des ennemis et tirs si contact self . ennemis_suppression () # suppression du vaisseau et ennemi si contact self . vaisseau_suppression () # ===================================================== # == DRAW # ===================================================== def draw ( self ): \"\"\"cr\u00e9ation et positionnement des objets (30 fois par seconde)\"\"\" # vide la fenetre pyxel . cls ( 0 ) # si le vaisseau possede des vies le jeu continue if self . vies > 0 : # vaisseau (carre 8x8) pyxel . rect ( self . vaisseau_x , self . vaisseau_y , 8 , 8 , 1 ) # tirs for tir in self . tirs_liste : pyxel . rect ( tir [ 0 ], tir [ 1 ], 1 , 4 , 10 ) # ennemis for ennemi in self . ennemis_liste : pyxel . rect ( ennemi [ 0 ], ennemi [ 1 ], 8 , 8 , 8 ) # sinon: GAME OVER else : pyxel . text ( 50 , 64 , 'GAME OVER' , 7 ) Jeu () Auteur : Laurent Abbal - GitHub | Twitter","title":"2. Terminale"},{"location":"PYTHON/Premiers%20pas%20avec%20Pyxel%20-%20Premi%C3%A8re%20et%20Terminale/Tutoriel-05/","text":"TUTORIEL #05 - Ajouter les explosions lors des collisions But : ajouter les explosions lors des collisions 1. Premi\u00e8re Programmation imp\u00e9rative : utilisation obligatoire de variables globales dans update . # on rajoute random import pyxel , random # taille de la fenetre 128x128 pixels # ne pas modifier pyxel . init ( 128 , 128 , title = \"Nuit du c0de\" ) # position initiale du vaisseau # (origine des positions : coin haut gauche) vaisseau_x = 60 vaisseau_y = 60 # vies vies = 4 # initialisation des tirs tirs_liste = [] # initialisation des ennemis ennemis_liste = [] # initialisation des explosions explosions_liste = [] def vaisseau_deplacement ( x , y ): \"\"\"d\u00e9placement avec les touches de directions\"\"\" if pyxel . btn ( pyxel . KEY_RIGHT ): if ( x < 120 ) : x = x + 1 if pyxel . btn ( pyxel . KEY_LEFT ): if ( x > 0 ) : x = x - 1 if pyxel . btn ( pyxel . KEY_DOWN ): if ( y < 120 ) : y = y + 1 if pyxel . btn ( pyxel . KEY_UP ): if ( y > 0 ) : y = y - 1 return x , y def tirs_creation ( x , y , tirs_liste ): \"\"\"cr\u00e9ation d'un tir avec la barre d'espace\"\"\" # btnr pour eviter les tirs multiples if pyxel . btnr ( pyxel . KEY_SPACE ): tirs_liste . append ([ x + 4 , y - 4 ]) return tirs_liste def tirs_deplacement ( tirs_liste ): \"\"\"d\u00e9placement des tirs vers le haut et suppression s'ils sortent du cadre\"\"\" for tir in tirs_liste : tir [ 1 ] -= 1 if tir [ 1 ] <- 8 : tirs_liste . remove ( tir ) return tirs_liste def ennemis_creation ( ennemis_liste ): \"\"\"cr\u00e9ation al\u00e9atoire des ennemis\"\"\" # un ennemi par seconde if ( pyxel . frame_count % 30 == 0 ): ennemis_liste . append ([ random . randint ( 0 , 120 ), 0 ]) return ennemis_liste def ennemis_deplacement ( ennemis_liste ): \"\"\"d\u00e9placement des ennemis vers le haut et suppression s'ils sortent du cadre\"\"\" for ennemi in ennemis_liste : ennemi [ 1 ] += 1 if ennemi [ 1 ] > 128 : ennemis_liste . remove ( ennemi ) return ennemis_liste def vaisseau_suppression ( vies ): \"\"\"disparition du vaisseau et d'un ennemi si contact\"\"\" for ennemi in ennemis_liste : if ennemi [ 0 ] <= vaisseau_x + 8 and ennemi [ 1 ] <= vaisseau_y + 8 and ennemi [ 0 ] + 8 >= vaisseau_x and ennemi [ 1 ] + 8 >= vaisseau_y : ennemis_liste . remove ( ennemi ) vies -= 1 # on ajoute l'explosion explosions_creation ( vaisseau_x , vaisseau_y ) return vies def ennemis_suppression (): \"\"\"disparition d'un ennemi et d'un tir si contact\"\"\" for ennemi in ennemis_liste : for tir in tirs_liste : if ennemi [ 0 ] <= tir [ 0 ] + 1 and ennemi [ 0 ] + 8 >= tir [ 0 ] and ennemi [ 1 ] + 8 >= tir [ 1 ]: ennemis_liste . remove ( ennemi ) tirs_liste . remove ( tir ) # on ajoute l'explosion explosions_creation ( ennemi [ 0 ], ennemi [ 1 ]) def explosions_creation ( x , y ): \"\"\"explosions aux points de collision entre deux objets\"\"\" explosions_liste . append ([ x , y , 0 ]) def explosions_animation (): \"\"\"animation des explosions\"\"\" for explosion in explosions_liste : explosion [ 2 ] += 1 if explosion [ 2 ] == 12 : explosions_liste . remove ( explosion ) # ========================================================= # == UPDATE # ========================================================= def update (): \"\"\"mise \u00e0 jour des variables (30 fois par seconde)\"\"\" global vaisseau_x , vaisseau_y , tirs_liste , ennemis_liste , vies , explosions_liste # mise \u00e0 jour de la position du vaisseau vaisseau_x , vaisseau_y = vaisseau_deplacement ( vaisseau_x , vaisseau_y ) # creation des tirs en fonction de la position du vaisseau tirs_liste = tirs_creation ( vaisseau_x , vaisseau_y , tirs_liste ) # mise a jour des positions des tirs tirs_liste = tirs_deplacement ( tirs_liste ) # creation des ennemis ennemis_liste = ennemis_creation ( ennemis_liste ) # mise a jour des positions des ennemis ennemis_liste = ennemis_deplacement ( ennemis_liste ) # suppression des ennemis et tirs si contact ennemis_suppression () # suppression du vaisseau et ennemi si contact vies = vaisseau_suppression ( vies ) # evolution de l'animation des explosions explosions_animation () # ========================================================= # == DRAW # ========================================================= def draw (): \"\"\"cr\u00e9ation des objets (30 fois par seconde)\"\"\" # vide la fenetre pyxel . cls ( 0 ) # si le vaisseau possede des vies le jeu continue if vies > 0 : # affichage des vies pyxel . text ( 5 , 5 , 'VIES:' + str ( vies ), 7 ) # vaisseau (carre 8x8) pyxel . rect ( vaisseau_x , vaisseau_y , 8 , 8 , 1 ) # tirs for tir in tirs_liste : pyxel . rect ( tir [ 0 ], tir [ 1 ], 1 , 4 , 10 ) # ennemis for ennemi in ennemis_liste : pyxel . rect ( ennemi [ 0 ], ennemi [ 1 ], 8 , 8 , 8 ) # explosions (cercles de plus en plus grands) for explosion in explosions_liste : pyxel . circb ( explosion [ 0 ] + 4 , explosion [ 1 ] + 4 , 2 * ( explosion [ 2 ] // 4 ), 8 + explosion [ 2 ] % 3 ) # sinon: GAME OVER else : pyxel . text ( 50 , 64 , 'GAME OVER' , 7 ) pyxel . run ( update , draw ) 2. Terminale Programmation orient\u00e9e objet # on rajoute random import pyxel , random class Jeu : def __init__ ( self ): # taille de la fenetre 128x128 pixels # ne pas modifier pyxel . init ( 128 , 128 , title = \"Nuit du c0de\" ) # position initiale du vaisseau # (origine des positions : coin haut gauche) self . vaisseau_x = 60 self . vaisseau_y = 60 # vies self . vies = 4 # initialisation des tirs self . tirs_liste = [] # initialisation des ennemis self . ennemis_liste = [] # initialisation des explosions self . explosions_liste = [] pyxel . run ( self . update , self . draw ) def deplacement ( self ): \"\"\"d\u00e9placement avec les touches de directions\"\"\" if pyxel . btn ( pyxel . KEY_RIGHT ) and self . vaisseau_x < 120 : self . vaisseau_x += 1 if pyxel . btn ( pyxel . KEY_LEFT ) and self . vaisseau_x > 0 : self . vaisseau_x += - 1 if pyxel . btn ( pyxel . KEY_DOWN ) and self . vaisseau_y < 120 : self . vaisseau_y += 1 if pyxel . btn ( pyxel . KEY_UP ) and self . vaisseau_y > 0 : self . vaisseau_y += - 1 def tirs_creation ( self ): \"\"\"cr\u00e9ation d'un tir avec la barre d'espace\"\"\" if pyxel . btnr ( pyxel . KEY_SPACE ): self . tirs_liste . append ([ self . vaisseau_x + 4 , self . vaisseau_y - 4 ]) def tirs_deplacement ( self ): \"\"\"d\u00e9placement des tirs vers le haut et suppression quand ils sortent du cadre\"\"\" for tir in self . tirs_liste : tir [ 1 ] -= 1 if tir [ 1 ] <- 8 : self . tirs_liste . remove ( tir ) def ennemis_creation ( self ): \"\"\"cr\u00e9ation al\u00e9atoire des ennemis\"\"\" # un ennemi par seconde if ( pyxel . frame_count % 30 == 0 ): self . ennemis_liste . append ([ random . randint ( 0 , 120 ), 0 ]) def ennemis_deplacement ( self ): \"\"\"d\u00e9placement des ennemis vers le haut et suppression s'ils sortent du cadre\"\"\" for ennemi in self . ennemis_liste : ennemi [ 1 ] += 1 if ennemi [ 1 ] > 128 : self . ennemis_liste . remove ( ennemi ) def vaisseau_suppression ( self ): \"\"\"disparition du vaisseau et d'un ennemi si contact\"\"\" for ennemi in self . ennemis_liste : if ennemi [ 0 ] <= self . vaisseau_x + 8 and ennemi [ 1 ] <= self . vaisseau_y + 8 and ennemi [ 0 ] + 8 >= self . vaisseau_x and ennemi [ 1 ] + 8 >= self . vaisseau_y : self . ennemis_liste . remove ( ennemi ) self . vies -= 1 # on ajoute l'explosion self . explosions_creation ( self . vaisseau_x , self . vaisseau_y ) def ennemis_suppression ( self ): \"\"\"disparition d'un ennemi et d'un tir si contact\"\"\" for ennemi in self . ennemis_liste : for tir in self . tirs_liste : if ennemi [ 0 ] <= tir [ 0 ] + 1 and ennemi [ 0 ] + 8 >= tir [ 0 ] and ennemi [ 1 ] + 8 >= tir [ 1 ]: self . ennemis_liste . remove ( ennemi ) self . tirs_liste . remove ( tir ) # on ajoute l'explosion self . explosions_creation ( ennemi [ 0 ], ennemi [ 1 ]) def explosions_creation ( self , x , y ): \"\"\"explosions aux points de collision entre deux objets\"\"\" self . explosions_liste . append ([ x , y , 0 ]) def explosions_animation ( self ): \"\"\"animation des explosions\"\"\" for explosion in self . explosions_liste : explosion [ 2 ] += 1 if explosion [ 2 ] == 12 : self . explosions_liste . remove ( explosion ) # ===================================================== # == UPDATE # ===================================================== def update ( self ): \"\"\"mise \u00e0 jour des variables (30 fois par seconde)\"\"\" # deplacement du vaisseau self . deplacement () # creation des tirs en fonction de la position du vaisseau self . tirs_creation () # mise a jour des positions des tirs self . tirs_deplacement () # creation des ennemis self . ennemis_creation () # mise a jour des positions des ennemis self . ennemis_deplacement () # suppression des ennemis et tirs si contact self . ennemis_suppression () # suppression du vaisseau et ennemi si contact self . vaisseau_suppression () # evolution de l'animation des explosions self . explosions_animation () # ===================================================== # == DRAW # ===================================================== def draw ( self ): \"\"\"cr\u00e9ation et positionnement des objets (30 fois par seconde)\"\"\" # vide la fenetre pyxel . cls ( 0 ) # si le vaisseau possede des vies le jeu continue if self . vies > 0 : # affichage des vies pyxel . text ( 5 , 5 , 'VIES:' + str ( self . vies ), 7 ) # vaisseau (carre 8x8) pyxel . rect ( self . vaisseau_x , self . vaisseau_y , 8 , 8 , 1 ) # tirs for tir in self . tirs_liste : pyxel . rect ( tir [ 0 ], tir [ 1 ], 1 , 4 , 10 ) # ennemis for ennemi in self . ennemis_liste : pyxel . rect ( ennemi [ 0 ], ennemi [ 1 ], 8 , 8 , 8 ) # explosions (cercles de plus en plus grands) for explosion in self . explosions_liste : pyxel . circb ( explosion [ 0 ] + 4 , explosion [ 1 ] + 4 , 2 * ( explosion [ 2 ] // 4 ), 8 + explosion [ 2 ] % 3 ) # sinon: GAME OVER else : pyxel . text ( 50 , 64 , 'GAME OVER' , 7 ) Jeu () Auteur : Laurent Abbal - GitHub | Twitter","title":"TUTORIEL #05 - Ajouter les explosions lors des collisions"},{"location":"PYTHON/Premiers%20pas%20avec%20Pyxel%20-%20Premi%C3%A8re%20et%20Terminale/Tutoriel-05/#tutoriel-05-ajouter-les-explosions-lors-des-collisions","text":"But : ajouter les explosions lors des collisions","title":"TUTORIEL #05 - Ajouter les explosions lors des collisions"},{"location":"PYTHON/Premiers%20pas%20avec%20Pyxel%20-%20Premi%C3%A8re%20et%20Terminale/Tutoriel-05/#1-premiere","text":"Programmation imp\u00e9rative : utilisation obligatoire de variables globales dans update . # on rajoute random import pyxel , random # taille de la fenetre 128x128 pixels # ne pas modifier pyxel . init ( 128 , 128 , title = \"Nuit du c0de\" ) # position initiale du vaisseau # (origine des positions : coin haut gauche) vaisseau_x = 60 vaisseau_y = 60 # vies vies = 4 # initialisation des tirs tirs_liste = [] # initialisation des ennemis ennemis_liste = [] # initialisation des explosions explosions_liste = [] def vaisseau_deplacement ( x , y ): \"\"\"d\u00e9placement avec les touches de directions\"\"\" if pyxel . btn ( pyxel . KEY_RIGHT ): if ( x < 120 ) : x = x + 1 if pyxel . btn ( pyxel . KEY_LEFT ): if ( x > 0 ) : x = x - 1 if pyxel . btn ( pyxel . KEY_DOWN ): if ( y < 120 ) : y = y + 1 if pyxel . btn ( pyxel . KEY_UP ): if ( y > 0 ) : y = y - 1 return x , y def tirs_creation ( x , y , tirs_liste ): \"\"\"cr\u00e9ation d'un tir avec la barre d'espace\"\"\" # btnr pour eviter les tirs multiples if pyxel . btnr ( pyxel . KEY_SPACE ): tirs_liste . append ([ x + 4 , y - 4 ]) return tirs_liste def tirs_deplacement ( tirs_liste ): \"\"\"d\u00e9placement des tirs vers le haut et suppression s'ils sortent du cadre\"\"\" for tir in tirs_liste : tir [ 1 ] -= 1 if tir [ 1 ] <- 8 : tirs_liste . remove ( tir ) return tirs_liste def ennemis_creation ( ennemis_liste ): \"\"\"cr\u00e9ation al\u00e9atoire des ennemis\"\"\" # un ennemi par seconde if ( pyxel . frame_count % 30 == 0 ): ennemis_liste . append ([ random . randint ( 0 , 120 ), 0 ]) return ennemis_liste def ennemis_deplacement ( ennemis_liste ): \"\"\"d\u00e9placement des ennemis vers le haut et suppression s'ils sortent du cadre\"\"\" for ennemi in ennemis_liste : ennemi [ 1 ] += 1 if ennemi [ 1 ] > 128 : ennemis_liste . remove ( ennemi ) return ennemis_liste def vaisseau_suppression ( vies ): \"\"\"disparition du vaisseau et d'un ennemi si contact\"\"\" for ennemi in ennemis_liste : if ennemi [ 0 ] <= vaisseau_x + 8 and ennemi [ 1 ] <= vaisseau_y + 8 and ennemi [ 0 ] + 8 >= vaisseau_x and ennemi [ 1 ] + 8 >= vaisseau_y : ennemis_liste . remove ( ennemi ) vies -= 1 # on ajoute l'explosion explosions_creation ( vaisseau_x , vaisseau_y ) return vies def ennemis_suppression (): \"\"\"disparition d'un ennemi et d'un tir si contact\"\"\" for ennemi in ennemis_liste : for tir in tirs_liste : if ennemi [ 0 ] <= tir [ 0 ] + 1 and ennemi [ 0 ] + 8 >= tir [ 0 ] and ennemi [ 1 ] + 8 >= tir [ 1 ]: ennemis_liste . remove ( ennemi ) tirs_liste . remove ( tir ) # on ajoute l'explosion explosions_creation ( ennemi [ 0 ], ennemi [ 1 ]) def explosions_creation ( x , y ): \"\"\"explosions aux points de collision entre deux objets\"\"\" explosions_liste . append ([ x , y , 0 ]) def explosions_animation (): \"\"\"animation des explosions\"\"\" for explosion in explosions_liste : explosion [ 2 ] += 1 if explosion [ 2 ] == 12 : explosions_liste . remove ( explosion ) # ========================================================= # == UPDATE # ========================================================= def update (): \"\"\"mise \u00e0 jour des variables (30 fois par seconde)\"\"\" global vaisseau_x , vaisseau_y , tirs_liste , ennemis_liste , vies , explosions_liste # mise \u00e0 jour de la position du vaisseau vaisseau_x , vaisseau_y = vaisseau_deplacement ( vaisseau_x , vaisseau_y ) # creation des tirs en fonction de la position du vaisseau tirs_liste = tirs_creation ( vaisseau_x , vaisseau_y , tirs_liste ) # mise a jour des positions des tirs tirs_liste = tirs_deplacement ( tirs_liste ) # creation des ennemis ennemis_liste = ennemis_creation ( ennemis_liste ) # mise a jour des positions des ennemis ennemis_liste = ennemis_deplacement ( ennemis_liste ) # suppression des ennemis et tirs si contact ennemis_suppression () # suppression du vaisseau et ennemi si contact vies = vaisseau_suppression ( vies ) # evolution de l'animation des explosions explosions_animation () # ========================================================= # == DRAW # ========================================================= def draw (): \"\"\"cr\u00e9ation des objets (30 fois par seconde)\"\"\" # vide la fenetre pyxel . cls ( 0 ) # si le vaisseau possede des vies le jeu continue if vies > 0 : # affichage des vies pyxel . text ( 5 , 5 , 'VIES:' + str ( vies ), 7 ) # vaisseau (carre 8x8) pyxel . rect ( vaisseau_x , vaisseau_y , 8 , 8 , 1 ) # tirs for tir in tirs_liste : pyxel . rect ( tir [ 0 ], tir [ 1 ], 1 , 4 , 10 ) # ennemis for ennemi in ennemis_liste : pyxel . rect ( ennemi [ 0 ], ennemi [ 1 ], 8 , 8 , 8 ) # explosions (cercles de plus en plus grands) for explosion in explosions_liste : pyxel . circb ( explosion [ 0 ] + 4 , explosion [ 1 ] + 4 , 2 * ( explosion [ 2 ] // 4 ), 8 + explosion [ 2 ] % 3 ) # sinon: GAME OVER else : pyxel . text ( 50 , 64 , 'GAME OVER' , 7 ) pyxel . run ( update , draw )","title":"1. Premi\u00e8re"},{"location":"PYTHON/Premiers%20pas%20avec%20Pyxel%20-%20Premi%C3%A8re%20et%20Terminale/Tutoriel-05/#2-terminale","text":"Programmation orient\u00e9e objet # on rajoute random import pyxel , random class Jeu : def __init__ ( self ): # taille de la fenetre 128x128 pixels # ne pas modifier pyxel . init ( 128 , 128 , title = \"Nuit du c0de\" ) # position initiale du vaisseau # (origine des positions : coin haut gauche) self . vaisseau_x = 60 self . vaisseau_y = 60 # vies self . vies = 4 # initialisation des tirs self . tirs_liste = [] # initialisation des ennemis self . ennemis_liste = [] # initialisation des explosions self . explosions_liste = [] pyxel . run ( self . update , self . draw ) def deplacement ( self ): \"\"\"d\u00e9placement avec les touches de directions\"\"\" if pyxel . btn ( pyxel . KEY_RIGHT ) and self . vaisseau_x < 120 : self . vaisseau_x += 1 if pyxel . btn ( pyxel . KEY_LEFT ) and self . vaisseau_x > 0 : self . vaisseau_x += - 1 if pyxel . btn ( pyxel . KEY_DOWN ) and self . vaisseau_y < 120 : self . vaisseau_y += 1 if pyxel . btn ( pyxel . KEY_UP ) and self . vaisseau_y > 0 : self . vaisseau_y += - 1 def tirs_creation ( self ): \"\"\"cr\u00e9ation d'un tir avec la barre d'espace\"\"\" if pyxel . btnr ( pyxel . KEY_SPACE ): self . tirs_liste . append ([ self . vaisseau_x + 4 , self . vaisseau_y - 4 ]) def tirs_deplacement ( self ): \"\"\"d\u00e9placement des tirs vers le haut et suppression quand ils sortent du cadre\"\"\" for tir in self . tirs_liste : tir [ 1 ] -= 1 if tir [ 1 ] <- 8 : self . tirs_liste . remove ( tir ) def ennemis_creation ( self ): \"\"\"cr\u00e9ation al\u00e9atoire des ennemis\"\"\" # un ennemi par seconde if ( pyxel . frame_count % 30 == 0 ): self . ennemis_liste . append ([ random . randint ( 0 , 120 ), 0 ]) def ennemis_deplacement ( self ): \"\"\"d\u00e9placement des ennemis vers le haut et suppression s'ils sortent du cadre\"\"\" for ennemi in self . ennemis_liste : ennemi [ 1 ] += 1 if ennemi [ 1 ] > 128 : self . ennemis_liste . remove ( ennemi ) def vaisseau_suppression ( self ): \"\"\"disparition du vaisseau et d'un ennemi si contact\"\"\" for ennemi in self . ennemis_liste : if ennemi [ 0 ] <= self . vaisseau_x + 8 and ennemi [ 1 ] <= self . vaisseau_y + 8 and ennemi [ 0 ] + 8 >= self . vaisseau_x and ennemi [ 1 ] + 8 >= self . vaisseau_y : self . ennemis_liste . remove ( ennemi ) self . vies -= 1 # on ajoute l'explosion self . explosions_creation ( self . vaisseau_x , self . vaisseau_y ) def ennemis_suppression ( self ): \"\"\"disparition d'un ennemi et d'un tir si contact\"\"\" for ennemi in self . ennemis_liste : for tir in self . tirs_liste : if ennemi [ 0 ] <= tir [ 0 ] + 1 and ennemi [ 0 ] + 8 >= tir [ 0 ] and ennemi [ 1 ] + 8 >= tir [ 1 ]: self . ennemis_liste . remove ( ennemi ) self . tirs_liste . remove ( tir ) # on ajoute l'explosion self . explosions_creation ( ennemi [ 0 ], ennemi [ 1 ]) def explosions_creation ( self , x , y ): \"\"\"explosions aux points de collision entre deux objets\"\"\" self . explosions_liste . append ([ x , y , 0 ]) def explosions_animation ( self ): \"\"\"animation des explosions\"\"\" for explosion in self . explosions_liste : explosion [ 2 ] += 1 if explosion [ 2 ] == 12 : self . explosions_liste . remove ( explosion ) # ===================================================== # == UPDATE # ===================================================== def update ( self ): \"\"\"mise \u00e0 jour des variables (30 fois par seconde)\"\"\" # deplacement du vaisseau self . deplacement () # creation des tirs en fonction de la position du vaisseau self . tirs_creation () # mise a jour des positions des tirs self . tirs_deplacement () # creation des ennemis self . ennemis_creation () # mise a jour des positions des ennemis self . ennemis_deplacement () # suppression des ennemis et tirs si contact self . ennemis_suppression () # suppression du vaisseau et ennemi si contact self . vaisseau_suppression () # evolution de l'animation des explosions self . explosions_animation () # ===================================================== # == DRAW # ===================================================== def draw ( self ): \"\"\"cr\u00e9ation et positionnement des objets (30 fois par seconde)\"\"\" # vide la fenetre pyxel . cls ( 0 ) # si le vaisseau possede des vies le jeu continue if self . vies > 0 : # affichage des vies pyxel . text ( 5 , 5 , 'VIES:' + str ( self . vies ), 7 ) # vaisseau (carre 8x8) pyxel . rect ( self . vaisseau_x , self . vaisseau_y , 8 , 8 , 1 ) # tirs for tir in self . tirs_liste : pyxel . rect ( tir [ 0 ], tir [ 1 ], 1 , 4 , 10 ) # ennemis for ennemi in self . ennemis_liste : pyxel . rect ( ennemi [ 0 ], ennemi [ 1 ], 8 , 8 , 8 ) # explosions (cercles de plus en plus grands) for explosion in self . explosions_liste : pyxel . circb ( explosion [ 0 ] + 4 , explosion [ 1 ] + 4 , 2 * ( explosion [ 2 ] // 4 ), 8 + explosion [ 2 ] % 3 ) # sinon: GAME OVER else : pyxel . text ( 50 , 64 , 'GAME OVER' , 7 ) Jeu () Auteur : Laurent Abbal - GitHub | Twitter","title":"2. Terminale"},{"location":"PYTHON/Premiers%20pas%20avec%20Pyxel%20-%20Premi%C3%A8re%20et%20Terminale/Tutoriel-06/","text":"TUTORIEL #06 - Ajouter les images But : ajouter les images Pour ouvrir l'\u00e9diteur d'image : ouvrir la console (avec Edupyter depuis Thonny : \"Outils\" > \"Ouvrir la console du syst\u00e8me...\", ou depuis le menu d'Edupyter : \"Console\") et saisir : pyxel edit [PYXEL_RESOURCE_FILE] \"Si le fichier de ressource Pyxel (.pyxres) existe d\u00e9j\u00e0, le fichier est charg\u00e9, sinon, un nouveau fichier avec le nom indiqu\u00e9 est cr\u00e9\u00e9. Si le fichier de ressource n\u2019est pas sp\u00e9cifi\u00e9, le nom est my_resource.pyxres.\" voir documentation 1. Premi\u00e8re Programmation imp\u00e9rative : utilisation obligatoire de variables globales dans update . # on rajoute random import pyxel , random # taille de la fenetre 128x128 pixels # ne pas modifier pyxel . init ( 128 , 128 , title = \"Nuit du c0de\" ) # position initiale du vaisseau # (origine des positions : coin haut gauche) vaisseau_x = 60 vaisseau_y = 60 # vies vies = 4 # initialisation des tirs tirs_liste = [] # initialisation des ennemis ennemis_liste = [] # initialisation des explosions explosions_liste = [] # chargement des images pyxel . load ( \"images.pyxres\" ) def vaisseau_deplacement ( x , y ): \"\"\"d\u00e9placement avec les touches de directions\"\"\" if pyxel . btn ( pyxel . KEY_RIGHT ): if ( x < 120 ) : x = x + 1 if pyxel . btn ( pyxel . KEY_LEFT ): if ( x > 0 ) : x = x - 1 if pyxel . btn ( pyxel . KEY_DOWN ): if ( y < 120 ) : y = y + 1 if pyxel . btn ( pyxel . KEY_UP ): if ( y > 0 ) : y = y - 1 return x , y def tirs_creation ( x , y , tirs_liste ): \"\"\"cr\u00e9ation d'un tir avec la barre d'espace\"\"\" # btnr pour eviter les tirs multiples if pyxel . btnr ( pyxel . KEY_SPACE ): tirs_liste . append ([ x + 4 , y - 4 ]) return tirs_liste def tirs_deplacement ( tirs_liste ): \"\"\"d\u00e9placement des tirs vers le haut et suppression s'ils sortent du cadre\"\"\" for tir in tirs_liste : tir [ 1 ] -= 1 if tir [ 1 ] <- 8 : tirs_liste . remove ( tir ) return tirs_liste def ennemis_creation ( ennemis_liste ): \"\"\"cr\u00e9ation al\u00e9atoire des ennemis\"\"\" # un ennemi par seconde if ( pyxel . frame_count % 30 == 0 ): ennemis_liste . append ([ random . randint ( 0 , 120 ), 0 ]) return ennemis_liste def ennemis_deplacement ( ennemis_liste ): \"\"\"d\u00e9placement des ennemis vers le haut et suppression s'ils sortent du cadre\"\"\" for ennemi in ennemis_liste : ennemi [ 1 ] += 1 if ennemi [ 1 ] > 128 : ennemis_liste . remove ( ennemi ) return ennemis_liste def vaisseau_suppression ( vies ): \"\"\"disparition du vaisseau et d'un ennemi si contact\"\"\" for ennemi in ennemis_liste : if ennemi [ 0 ] <= vaisseau_x + 8 and ennemi [ 1 ] <= vaisseau_y + 8 and ennemi [ 0 ] + 8 >= vaisseau_x and ennemi [ 1 ] + 8 >= vaisseau_y : ennemis_liste . remove ( ennemi ) vies -= 1 # on ajoute l'explosion explosions_creation ( vaisseau_x , vaisseau_y ) return vies def ennemis_suppression (): \"\"\"disparition d'un ennemi et d'un tir si contact\"\"\" for ennemi in ennemis_liste : for tir in tirs_liste : if ennemi [ 0 ] <= tir [ 0 ] + 1 and ennemi [ 0 ] + 8 >= tir [ 0 ] and ennemi [ 1 ] + 8 >= tir [ 1 ]: ennemis_liste . remove ( ennemi ) tirs_liste . remove ( tir ) # on ajoute l'explosion explosions_creation ( ennemi [ 0 ], ennemi [ 1 ]) def explosions_creation ( x , y ): \"\"\"explosions aux points de collision entre deux objets\"\"\" explosions_liste . append ([ x , y , 0 ]) def explosions_animation (): \"\"\"animation des explosions\"\"\" for explosion in explosions_liste : explosion [ 2 ] += 1 if explosion [ 2 ] == 12 : explosions_liste . remove ( explosion ) # ========================================================= # == UPDATE # ========================================================= def update (): \"\"\"mise \u00e0 jour des variables (30 fois par seconde)\"\"\" global vaisseau_x , vaisseau_y , tirs_liste , ennemis_liste , vies , explosions_liste # mise \u00e0 jour de la position du vaisseau vaisseau_x , vaisseau_y = vaisseau_deplacement ( vaisseau_x , vaisseau_y ) # creation des tirs en fonction de la position du vaisseau tirs_liste = tirs_creation ( vaisseau_x , vaisseau_y , tirs_liste ) # mise a jour des positions des tirs tirs_liste = tirs_deplacement ( tirs_liste ) # creation des ennemis ennemis_liste = ennemis_creation ( ennemis_liste ) # mise a jour des positions des ennemis ennemis_liste = ennemis_deplacement ( ennemis_liste ) # suppression des ennemis et tirs si contact ennemis_suppression () # suppression du vaisseau et ennemi si contact vies = vaisseau_suppression ( vies ) # evolution de l'animation des explosions explosions_animation () # ========================================================= # == DRAW # ========================================================= def draw (): \"\"\"cr\u00e9ation des objets (30 fois par seconde)\"\"\" # vide la fenetre pyxel . cls ( 0 ) # si le vaisseau possede des vies le jeu continue if vies > 0 : # affichage des vies pyxel . text ( 5 , 5 , 'VIES:' + str ( vies ), 7 ) # vaisseau (carre 8x8) pyxel . blt ( vaisseau_x , vaisseau_y , 0 , 0 , 0 , 8 , 8 ) # tirs for tir in tirs_liste : pyxel . blt ( tir [ 0 ], tir [ 1 ], 0 , 8 , 0 , 8 , 8 ) # ennemis for ennemi in ennemis_liste : pyxel . blt ( ennemi [ 0 ], ennemi [ 1 ], 0 , 0 , 8 , 8 , 8 ) # explosions (cercles de plus en plus grands) for explosion in explosions_liste : pyxel . circb ( explosion [ 0 ] + 4 , explosion [ 1 ] + 4 , 2 * ( explosion [ 2 ] // 4 ), 8 + explosion [ 2 ] % 3 ) # sinon: GAME OVER else : pyxel . text ( 50 , 64 , 'GAME OVER' , 7 ) pyxel . run ( update , draw ) 2. Terminale Programmation orient\u00e9e objet # on rajoute random import pyxel , random class Jeu : def __init__ ( self ): # taille de la fenetre 128x128 pixels # ne pas modifier pyxel . init ( 128 , 128 , title = \"Nuit du c0de\" ) # position initiale du vaisseau # (origine des positions : coin haut gauche) self . vaisseau_x = 60 self . vaisseau_y = 60 # vies self . vies = 4 # initialisation des tirs self . tirs_liste = [] # initialisation des ennemis self . ennemis_liste = [] # initialisation des explosions self . explosions_liste = [] # chargement des images pyxel . load ( \"images.pyxres\" ) pyxel . run ( self . update , self . draw ) def deplacement ( self ): \"\"\"d\u00e9placement avec les touches de directions\"\"\" if pyxel . btn ( pyxel . KEY_RIGHT ) and self . vaisseau_x < 120 : self . vaisseau_x += 1 if pyxel . btn ( pyxel . KEY_LEFT ) and self . vaisseau_x > 0 : self . vaisseau_x += - 1 if pyxel . btn ( pyxel . KEY_DOWN ) and self . vaisseau_y < 120 : self . vaisseau_y += 1 if pyxel . btn ( pyxel . KEY_UP ) and self . vaisseau_y > 0 : self . vaisseau_y += - 1 def tirs_creation ( self ): \"\"\"cr\u00e9ation d'un tir avec la barre d'espace\"\"\" if pyxel . btnr ( pyxel . KEY_SPACE ): self . tirs_liste . append ([ self . vaisseau_x , self . vaisseau_y - 8 ]) def tirs_deplacement ( self ): \"\"\"d\u00e9placement des tirs vers le haut et suppression quand ils sortent du cadre\"\"\" for tir in self . tirs_liste : tir [ 1 ] -= 1 if tir [ 1 ] <- 8 : self . tirs_liste . remove ( tir ) def ennemis_creation ( self ): \"\"\"cr\u00e9ation al\u00e9atoire des ennemis\"\"\" # un ennemi par seconde if ( pyxel . frame_count % 30 == 0 ): self . ennemis_liste . append ([ random . randint ( 0 , 120 ), 0 ]) def ennemis_deplacement ( self ): \"\"\"d\u00e9placement des ennemis vers le haut et suppression s'ils sortent du cadre\"\"\" for ennemi in self . ennemis_liste : ennemi [ 1 ] += 1 if ennemi [ 1 ] > 128 : self . ennemis_liste . remove ( ennemi ) def vaisseau_suppression ( self ): \"\"\"disparition du vaisseau et d'un ennemi si contact\"\"\" for ennemi in self . ennemis_liste : if ennemi [ 0 ] <= self . vaisseau_x + 8 and ennemi [ 1 ] <= self . vaisseau_y + 8 and ennemi [ 0 ] + 8 >= self . vaisseau_x and ennemi [ 1 ] + 8 >= self . vaisseau_y : self . ennemis_liste . remove ( ennemi ) self . vies -= 1 # on ajoute l'explosion self . explosions_creation ( self . vaisseau_x , self . vaisseau_y ) def ennemis_suppression ( self ): \"\"\"disparition d'un ennemi et d'un tir si contact\"\"\" for ennemi in self . ennemis_liste : for tir in self . tirs_liste : if ennemi [ 0 ] <= tir [ 0 ] + 8 and ennemi [ 0 ] + 8 >= tir [ 0 ] and ennemi [ 1 ] + 8 >= tir [ 1 ]: self . ennemis_liste . remove ( ennemi ) self . tirs_liste . remove ( tir ) # on ajoute l'explosion self . explosions_creation ( ennemi [ 0 ], ennemi [ 1 ]) def explosions_creation ( self , x , y ): \"\"\"explosions aux points de collision entre deux objets\"\"\" self . explosions_liste . append ([ x , y , 0 ]) def explosions_animation ( self ): \"\"\"animation des explosions\"\"\" for explosion in self . explosions_liste : explosion [ 2 ] += 1 if explosion [ 2 ] == 12 : self . explosions_liste . remove ( explosion ) # ===================================================== # == UPDATE # ===================================================== def update ( self ): \"\"\"mise \u00e0 jour des variables (30 fois par seconde)\"\"\" # deplacement du vaisseau self . deplacement () # creation des tirs en fonction de la position du vaisseau self . tirs_creation () # mise a jour des positions des tirs self . tirs_deplacement () # creation des ennemis self . ennemis_creation () # mise a jour des positions des ennemis self . ennemis_deplacement () # suppression des ennemis et tirs si contact self . ennemis_suppression () # suppression du vaisseau et ennemi si contact self . vaisseau_suppression () # evolution de l'animation des explosions self . explosions_animation () # ===================================================== # == DRAW # ===================================================== def draw ( self ): \"\"\"cr\u00e9ation et positionnement des objets (30 fois par seconde)\"\"\" # vide la fenetre pyxel . cls ( 0 ) # si le vaisseau possede des vies le jeu continue if self . vies > 0 : # affichage des vies pyxel . text ( 5 , 5 , 'VIES:' + str ( self . vies ), 7 ) # vaisseau (carre 8x8) pyxel . blt ( self . vaisseau_x , self . vaisseau_y , 0 , 0 , 0 , 8 , 8 ) # tirs for tir in self . tirs_liste : pyxel . blt ( tir [ 0 ], tir [ 1 ], 0 , 8 , 0 , 8 , 8 ) # ennemis for ennemi in self . ennemis_liste : pyxel . blt ( ennemi [ 0 ], ennemi [ 1 ], 0 , 0 , 8 , 8 , 8 ) # explosions (cercles de plus en plus grands) for explosion in self . explosions_liste : pyxel . circb ( explosion [ 0 ] + 4 , explosion [ 1 ] + 4 , 2 * ( explosion [ 2 ] // 4 ), 8 + explosion [ 2 ] % 3 ) # sinon: GAME OVER else : pyxel . text ( 50 , 64 , 'GAME OVER' , 7 ) Jeu () Auteur : Laurent Abbal - GitHub | Twitter","title":"TUTORIEL #06 - Ajouter les images"},{"location":"PYTHON/Premiers%20pas%20avec%20Pyxel%20-%20Premi%C3%A8re%20et%20Terminale/Tutoriel-06/#tutoriel-06-ajouter-les-images","text":"But : ajouter les images Pour ouvrir l'\u00e9diteur d'image : ouvrir la console (avec Edupyter depuis Thonny : \"Outils\" > \"Ouvrir la console du syst\u00e8me...\", ou depuis le menu d'Edupyter : \"Console\") et saisir : pyxel edit [PYXEL_RESOURCE_FILE] \"Si le fichier de ressource Pyxel (.pyxres) existe d\u00e9j\u00e0, le fichier est charg\u00e9, sinon, un nouveau fichier avec le nom indiqu\u00e9 est cr\u00e9\u00e9. Si le fichier de ressource n\u2019est pas sp\u00e9cifi\u00e9, le nom est my_resource.pyxres.\" voir documentation","title":"TUTORIEL #06 - Ajouter les images"},{"location":"PYTHON/Premiers%20pas%20avec%20Pyxel%20-%20Premi%C3%A8re%20et%20Terminale/Tutoriel-06/#1-premiere","text":"Programmation imp\u00e9rative : utilisation obligatoire de variables globales dans update . # on rajoute random import pyxel , random # taille de la fenetre 128x128 pixels # ne pas modifier pyxel . init ( 128 , 128 , title = \"Nuit du c0de\" ) # position initiale du vaisseau # (origine des positions : coin haut gauche) vaisseau_x = 60 vaisseau_y = 60 # vies vies = 4 # initialisation des tirs tirs_liste = [] # initialisation des ennemis ennemis_liste = [] # initialisation des explosions explosions_liste = [] # chargement des images pyxel . load ( \"images.pyxres\" ) def vaisseau_deplacement ( x , y ): \"\"\"d\u00e9placement avec les touches de directions\"\"\" if pyxel . btn ( pyxel . KEY_RIGHT ): if ( x < 120 ) : x = x + 1 if pyxel . btn ( pyxel . KEY_LEFT ): if ( x > 0 ) : x = x - 1 if pyxel . btn ( pyxel . KEY_DOWN ): if ( y < 120 ) : y = y + 1 if pyxel . btn ( pyxel . KEY_UP ): if ( y > 0 ) : y = y - 1 return x , y def tirs_creation ( x , y , tirs_liste ): \"\"\"cr\u00e9ation d'un tir avec la barre d'espace\"\"\" # btnr pour eviter les tirs multiples if pyxel . btnr ( pyxel . KEY_SPACE ): tirs_liste . append ([ x + 4 , y - 4 ]) return tirs_liste def tirs_deplacement ( tirs_liste ): \"\"\"d\u00e9placement des tirs vers le haut et suppression s'ils sortent du cadre\"\"\" for tir in tirs_liste : tir [ 1 ] -= 1 if tir [ 1 ] <- 8 : tirs_liste . remove ( tir ) return tirs_liste def ennemis_creation ( ennemis_liste ): \"\"\"cr\u00e9ation al\u00e9atoire des ennemis\"\"\" # un ennemi par seconde if ( pyxel . frame_count % 30 == 0 ): ennemis_liste . append ([ random . randint ( 0 , 120 ), 0 ]) return ennemis_liste def ennemis_deplacement ( ennemis_liste ): \"\"\"d\u00e9placement des ennemis vers le haut et suppression s'ils sortent du cadre\"\"\" for ennemi in ennemis_liste : ennemi [ 1 ] += 1 if ennemi [ 1 ] > 128 : ennemis_liste . remove ( ennemi ) return ennemis_liste def vaisseau_suppression ( vies ): \"\"\"disparition du vaisseau et d'un ennemi si contact\"\"\" for ennemi in ennemis_liste : if ennemi [ 0 ] <= vaisseau_x + 8 and ennemi [ 1 ] <= vaisseau_y + 8 and ennemi [ 0 ] + 8 >= vaisseau_x and ennemi [ 1 ] + 8 >= vaisseau_y : ennemis_liste . remove ( ennemi ) vies -= 1 # on ajoute l'explosion explosions_creation ( vaisseau_x , vaisseau_y ) return vies def ennemis_suppression (): \"\"\"disparition d'un ennemi et d'un tir si contact\"\"\" for ennemi in ennemis_liste : for tir in tirs_liste : if ennemi [ 0 ] <= tir [ 0 ] + 1 and ennemi [ 0 ] + 8 >= tir [ 0 ] and ennemi [ 1 ] + 8 >= tir [ 1 ]: ennemis_liste . remove ( ennemi ) tirs_liste . remove ( tir ) # on ajoute l'explosion explosions_creation ( ennemi [ 0 ], ennemi [ 1 ]) def explosions_creation ( x , y ): \"\"\"explosions aux points de collision entre deux objets\"\"\" explosions_liste . append ([ x , y , 0 ]) def explosions_animation (): \"\"\"animation des explosions\"\"\" for explosion in explosions_liste : explosion [ 2 ] += 1 if explosion [ 2 ] == 12 : explosions_liste . remove ( explosion ) # ========================================================= # == UPDATE # ========================================================= def update (): \"\"\"mise \u00e0 jour des variables (30 fois par seconde)\"\"\" global vaisseau_x , vaisseau_y , tirs_liste , ennemis_liste , vies , explosions_liste # mise \u00e0 jour de la position du vaisseau vaisseau_x , vaisseau_y = vaisseau_deplacement ( vaisseau_x , vaisseau_y ) # creation des tirs en fonction de la position du vaisseau tirs_liste = tirs_creation ( vaisseau_x , vaisseau_y , tirs_liste ) # mise a jour des positions des tirs tirs_liste = tirs_deplacement ( tirs_liste ) # creation des ennemis ennemis_liste = ennemis_creation ( ennemis_liste ) # mise a jour des positions des ennemis ennemis_liste = ennemis_deplacement ( ennemis_liste ) # suppression des ennemis et tirs si contact ennemis_suppression () # suppression du vaisseau et ennemi si contact vies = vaisseau_suppression ( vies ) # evolution de l'animation des explosions explosions_animation () # ========================================================= # == DRAW # ========================================================= def draw (): \"\"\"cr\u00e9ation des objets (30 fois par seconde)\"\"\" # vide la fenetre pyxel . cls ( 0 ) # si le vaisseau possede des vies le jeu continue if vies > 0 : # affichage des vies pyxel . text ( 5 , 5 , 'VIES:' + str ( vies ), 7 ) # vaisseau (carre 8x8) pyxel . blt ( vaisseau_x , vaisseau_y , 0 , 0 , 0 , 8 , 8 ) # tirs for tir in tirs_liste : pyxel . blt ( tir [ 0 ], tir [ 1 ], 0 , 8 , 0 , 8 , 8 ) # ennemis for ennemi in ennemis_liste : pyxel . blt ( ennemi [ 0 ], ennemi [ 1 ], 0 , 0 , 8 , 8 , 8 ) # explosions (cercles de plus en plus grands) for explosion in explosions_liste : pyxel . circb ( explosion [ 0 ] + 4 , explosion [ 1 ] + 4 , 2 * ( explosion [ 2 ] // 4 ), 8 + explosion [ 2 ] % 3 ) # sinon: GAME OVER else : pyxel . text ( 50 , 64 , 'GAME OVER' , 7 ) pyxel . run ( update , draw )","title":"1. Premi\u00e8re"},{"location":"PYTHON/Premiers%20pas%20avec%20Pyxel%20-%20Premi%C3%A8re%20et%20Terminale/Tutoriel-06/#2-terminale","text":"Programmation orient\u00e9e objet # on rajoute random import pyxel , random class Jeu : def __init__ ( self ): # taille de la fenetre 128x128 pixels # ne pas modifier pyxel . init ( 128 , 128 , title = \"Nuit du c0de\" ) # position initiale du vaisseau # (origine des positions : coin haut gauche) self . vaisseau_x = 60 self . vaisseau_y = 60 # vies self . vies = 4 # initialisation des tirs self . tirs_liste = [] # initialisation des ennemis self . ennemis_liste = [] # initialisation des explosions self . explosions_liste = [] # chargement des images pyxel . load ( \"images.pyxres\" ) pyxel . run ( self . update , self . draw ) def deplacement ( self ): \"\"\"d\u00e9placement avec les touches de directions\"\"\" if pyxel . btn ( pyxel . KEY_RIGHT ) and self . vaisseau_x < 120 : self . vaisseau_x += 1 if pyxel . btn ( pyxel . KEY_LEFT ) and self . vaisseau_x > 0 : self . vaisseau_x += - 1 if pyxel . btn ( pyxel . KEY_DOWN ) and self . vaisseau_y < 120 : self . vaisseau_y += 1 if pyxel . btn ( pyxel . KEY_UP ) and self . vaisseau_y > 0 : self . vaisseau_y += - 1 def tirs_creation ( self ): \"\"\"cr\u00e9ation d'un tir avec la barre d'espace\"\"\" if pyxel . btnr ( pyxel . KEY_SPACE ): self . tirs_liste . append ([ self . vaisseau_x , self . vaisseau_y - 8 ]) def tirs_deplacement ( self ): \"\"\"d\u00e9placement des tirs vers le haut et suppression quand ils sortent du cadre\"\"\" for tir in self . tirs_liste : tir [ 1 ] -= 1 if tir [ 1 ] <- 8 : self . tirs_liste . remove ( tir ) def ennemis_creation ( self ): \"\"\"cr\u00e9ation al\u00e9atoire des ennemis\"\"\" # un ennemi par seconde if ( pyxel . frame_count % 30 == 0 ): self . ennemis_liste . append ([ random . randint ( 0 , 120 ), 0 ]) def ennemis_deplacement ( self ): \"\"\"d\u00e9placement des ennemis vers le haut et suppression s'ils sortent du cadre\"\"\" for ennemi in self . ennemis_liste : ennemi [ 1 ] += 1 if ennemi [ 1 ] > 128 : self . ennemis_liste . remove ( ennemi ) def vaisseau_suppression ( self ): \"\"\"disparition du vaisseau et d'un ennemi si contact\"\"\" for ennemi in self . ennemis_liste : if ennemi [ 0 ] <= self . vaisseau_x + 8 and ennemi [ 1 ] <= self . vaisseau_y + 8 and ennemi [ 0 ] + 8 >= self . vaisseau_x and ennemi [ 1 ] + 8 >= self . vaisseau_y : self . ennemis_liste . remove ( ennemi ) self . vies -= 1 # on ajoute l'explosion self . explosions_creation ( self . vaisseau_x , self . vaisseau_y ) def ennemis_suppression ( self ): \"\"\"disparition d'un ennemi et d'un tir si contact\"\"\" for ennemi in self . ennemis_liste : for tir in self . tirs_liste : if ennemi [ 0 ] <= tir [ 0 ] + 8 and ennemi [ 0 ] + 8 >= tir [ 0 ] and ennemi [ 1 ] + 8 >= tir [ 1 ]: self . ennemis_liste . remove ( ennemi ) self . tirs_liste . remove ( tir ) # on ajoute l'explosion self . explosions_creation ( ennemi [ 0 ], ennemi [ 1 ]) def explosions_creation ( self , x , y ): \"\"\"explosions aux points de collision entre deux objets\"\"\" self . explosions_liste . append ([ x , y , 0 ]) def explosions_animation ( self ): \"\"\"animation des explosions\"\"\" for explosion in self . explosions_liste : explosion [ 2 ] += 1 if explosion [ 2 ] == 12 : self . explosions_liste . remove ( explosion ) # ===================================================== # == UPDATE # ===================================================== def update ( self ): \"\"\"mise \u00e0 jour des variables (30 fois par seconde)\"\"\" # deplacement du vaisseau self . deplacement () # creation des tirs en fonction de la position du vaisseau self . tirs_creation () # mise a jour des positions des tirs self . tirs_deplacement () # creation des ennemis self . ennemis_creation () # mise a jour des positions des ennemis self . ennemis_deplacement () # suppression des ennemis et tirs si contact self . ennemis_suppression () # suppression du vaisseau et ennemi si contact self . vaisseau_suppression () # evolution de l'animation des explosions self . explosions_animation () # ===================================================== # == DRAW # ===================================================== def draw ( self ): \"\"\"cr\u00e9ation et positionnement des objets (30 fois par seconde)\"\"\" # vide la fenetre pyxel . cls ( 0 ) # si le vaisseau possede des vies le jeu continue if self . vies > 0 : # affichage des vies pyxel . text ( 5 , 5 , 'VIES:' + str ( self . vies ), 7 ) # vaisseau (carre 8x8) pyxel . blt ( self . vaisseau_x , self . vaisseau_y , 0 , 0 , 0 , 8 , 8 ) # tirs for tir in self . tirs_liste : pyxel . blt ( tir [ 0 ], tir [ 1 ], 0 , 8 , 0 , 8 , 8 ) # ennemis for ennemi in self . ennemis_liste : pyxel . blt ( ennemi [ 0 ], ennemi [ 1 ], 0 , 0 , 8 , 8 , 8 ) # explosions (cercles de plus en plus grands) for explosion in self . explosions_liste : pyxel . circb ( explosion [ 0 ] + 4 , explosion [ 1 ] + 4 , 2 * ( explosion [ 2 ] // 4 ), 8 + explosion [ 2 ] % 3 ) # sinon: GAME OVER else : pyxel . text ( 50 , 64 , 'GAME OVER' , 7 ) Jeu () Auteur : Laurent Abbal - GitHub | Twitter","title":"2. Terminale"},{"location":"PYTHON/Premiers%20pas%20avec%20Pyxel%20-%20Premi%C3%A8re%20et%20Terminale/Tutoriel-07%20-%20Compl%C3%A9ments/","text":"COMPL\u00c9MENTS Tutoriel #01 Trois Parties: d\u00e9claration des variables et des fonctions fonction update() fonction draw() Exemple d'utilisation pour le d\u00e9placement du vaisseau. D\u00e9claration des variables et des fonctions Position du vaisseau par la cr\u00e9ation des coordonn\u00e9es du vaisseau au d\u00e9part. Pour l'instant il n'y a pas de vaisseau, juste deux variables vaisseau_x et vaisseau_y initialis\u00e9es par les valeurs 60. vaisseau_x = 60 vaisseau_y = 60 Cette fonction a pour arguments les valeurs des variables x et y et renvoie les valeurs des variables x et y modifi\u00e9es suivant certaines touches du clavier. def vaisseau_deplacement ( x , y ): \"\"\"d\u00e9placement avec les touches de directions\"\"\" if pyxel . btn ( pyxel . KEY_RIGHT ): if ( x < 120 ) : x = x + 1 if pyxel . btn ( pyxel . KEY_LEFT ): if ( x > 0 ) : x = x - 1 if pyxel . btn ( pyxel . KEY_DOWN ): if ( y < 120 ) : y = y + 1 if pyxel . btn ( pyxel . KEY_UP ): if ( y > 0 ) : y = y - 1 return x , y Fonction update() Cette fonction update() est appel\u00e9 30 fois par seconde. def update (): \"\"\"mise \u00e0 jour des variables (30 fois par seconde)\"\"\" global vaisseau_x , vaisseau_y # mise \u00e0 jour de la position du vaisseau vaisseau_x , vaisseau_y = vaisseau_deplacement ( vaisseau_x , vaisseau_y ) Que fait cette instruction (affectation) ? vaisseau_x , vaisseau_y = vaisseau_deplacement ( vaisseau_x , vaisseau_y ) L'appel de la fonction vaisseau_deplacement(vaisseau_x, vaisseau_y) avec pour arguments les valeurs des variables vaisseau_x et vaisseau_y et renvoie les valeurs modifi\u00e9es suivant certaines touches du clavier. Ces valeurs renvoy\u00e9es sont affect\u00e9es aux variables vaisseau_x et vaisseau_y . Les valeurs des variables vaisseau_x et vaisseau_y sont modifi\u00e9es 30 fois par seconde suivant certaines touches du clavier. Fonction draw() Enfin le dessin ! Pour l'instant il n'y a pas encore de vaisseau. On a cr\u00e9\u00e9 deux variables vaisseau_x et vaisseau_y qui sont modifi\u00e9es par l'appel de la fonction update() 30 fois par seconde permettant de r\u00e9aliser cette instruction. vaisseau_x , vaisseau_y = vaisseau_deplacement ( vaisseau_x , vaisseau_y ) Cette fonction draw() est appel\u00e9 30 fois par seconde. def draw (): \"\"\"cr\u00e9ation des objets (30 fois par seconde)\"\"\" # vide la fenetre pyxel . cls ( 0 ) # vaisseau (carre 8x8) pyxel . rect ( vaisseau_x , vaisseau_y , 8 , 8 , 1 ) L'instruction pyxel.rect(vaisseau_x, vaisseau_y, 8, 8, 1) permet de dessiner un rectangle ayant comme coordonn\u00e9es coin gauche les valeurs des variables vaisseau_x et vaisseau_y , de largeur 8, de hauteur 8 et de couleur 1. A quoi sert l'instruction python pyxel.cls(0) ? La commenter et essayer ? La modifier en python pyxel.cls(3) et essayer ? La modifier en python pyxel.cls(1) et essayer ? 30 fois par seconde deux actions sont r\u00e9alis\u00e9es : la fen\u00eatre graphique est remplie d'une couleur on dessine une rectangle Cela donne l'illusion d'un mouvement comme au cin\u00e9ma. Tutoriel #02 Halo autour du tir pyxel . rectb ( tir [ 0 ] - 1 , tir [ 1 ] - 1 , 3 , 6 , 3 ) Tir sous forme cercle avec halo pyxel . circ ( tir [ 0 ], tir [ 1 ], 2 , 3 ) pyxel . circb ( tir [ 0 ], tir [ 1 ], 3 , 9 ) Tir sous forme cercle avec halo clignotant import random pyxel . circb ( tir [ 0 ], tir [ 1 ], 3 , random . randint ( 1 , 10 )) Tutoriel #03 Mettre en parall\u00e8le la cr\u00e9ation des tirs et des ennemis. Utilisation de listes pour enregistrer les coordonn\u00e9es sous la forme de liste. Ajout de valeurs (coordonn\u00e9es) par rapport au vaisseau par appui sur une touche. Ajout de valeurs (coordonn\u00e9es) al\u00e9atoire pour l'abscisse suivant une dur\u00e9e. def tirs_creation ( x , y , tirs_liste ): \"\"\"cr\u00e9ation d'un tir avec la barre d'espace\"\"\" # btnr pour eviter les tirs multiples if pyxel . btnr ( pyxel . KEY_SPACE ): tirs_liste . append ([ x + 4 , y - 4 ]) return tirs_liste def ennemis_creation ( ennemis_liste ): \"\"\"cr\u00e9ation al\u00e9atoire des ennemis\"\"\" # un ennemi par seconde if ( pyxel . frame_count % 30 == 0 ): ennemis_liste . append ([ random . randint ( 0 , 120 ), 0 ]) return ennemis_liste Mise \u00e0 jour des valeurs des diff\u00e9rentes listes suivant des conditions. def tirs_deplacement ( tirs_liste ): \"\"\"d\u00e9placement des tirs vers le haut et suppression s'ils sortent du cadre\"\"\" for tir in tirs_liste : tir [ 1 ] -= 1 if tir [ 1 ] <- 8 : tirs_liste . remove ( tir ) return tirs_liste def ennemis_deplacement ( ennemis_liste ): \"\"\"d\u00e9placement des ennemis vers le haut et suppression s'ils sortent du cadre\"\"\" for ennemi in ennemis_liste : ennemi [ 1 ] += 1 if ennemi [ 1 ] > 128 : ennemis_liste . remove ( ennemi ) return ennemis_liste Fonction update() La fonction update() est appel\u00e9 30 fois par seconde permettant la mise \u00e0 jour des diff\u00e9rentes variables. def update (): \"\"\"mise \u00e0 jour des variables (30 fois par seconde)\"\"\" global vaisseau_x , vaisseau_y , tirs_liste , ennemis_liste # mise \u00e0 jour de la position du vaisseau vaisseau_x , vaisseau_y = vaisseau_deplacement ( vaisseau_x , vaisseau_y ) # creation des tirs en fonction de la position du vaisseau tirs_liste = tirs_creation ( vaisseau_x , vaisseau_y , tirs_liste ) # mise a jour des positions des tirs tirs_liste = tirs_deplacement ( tirs_liste ) # creation des ennemis ennemis_liste = ennemis_creation ( ennemis_liste ) # mise a jour des positions des ennemis ennemis_liste = ennemis_deplacement ( ennemis_liste ) Fonction draw() Enfin le dessin ! La fonction draw() est appel\u00e9 30 fois par seconde. def draw (): \"\"\"cr\u00e9ation des objets (30 fois par seconde)\"\"\" # vide la fenetre pyxel . cls ( 0 ) # vaisseau (carre 8x8) pyxel . rect ( vaisseau_x , vaisseau_y , 8 , 8 , 1 ) # tirs for tir in tirs_liste : pyxel . rect ( tir [ 0 ], tir [ 1 ], 1 , 4 , 10 ) # ennemis for ennemi in ennemis_liste : pyxel . rect ( ennemi [ 0 ], ennemi [ 1 ], 8 , 8 , 8 ) Auteur : Charles Poulmaire - Twitter","title":"COMPL\u00c9MENTS"},{"location":"PYTHON/Premiers%20pas%20avec%20Pyxel%20-%20Premi%C3%A8re%20et%20Terminale/Tutoriel-07%20-%20Compl%C3%A9ments/#complements","text":"","title":"COMPL\u00c9MENTS"},{"location":"PYTHON/Premiers%20pas%20avec%20Pyxel%20-%20Premi%C3%A8re%20et%20Terminale/Tutoriel-07%20-%20Compl%C3%A9ments/#tutoriel-01","text":"Trois Parties: d\u00e9claration des variables et des fonctions fonction update() fonction draw() Exemple d'utilisation pour le d\u00e9placement du vaisseau.","title":"Tutoriel #01"},{"location":"PYTHON/Premiers%20pas%20avec%20Pyxel%20-%20Premi%C3%A8re%20et%20Terminale/Tutoriel-07%20-%20Compl%C3%A9ments/#declaration-des-variables-et-des-fonctions","text":"Position du vaisseau par la cr\u00e9ation des coordonn\u00e9es du vaisseau au d\u00e9part. Pour l'instant il n'y a pas de vaisseau, juste deux variables vaisseau_x et vaisseau_y initialis\u00e9es par les valeurs 60. vaisseau_x = 60 vaisseau_y = 60 Cette fonction a pour arguments les valeurs des variables x et y et renvoie les valeurs des variables x et y modifi\u00e9es suivant certaines touches du clavier. def vaisseau_deplacement ( x , y ): \"\"\"d\u00e9placement avec les touches de directions\"\"\" if pyxel . btn ( pyxel . KEY_RIGHT ): if ( x < 120 ) : x = x + 1 if pyxel . btn ( pyxel . KEY_LEFT ): if ( x > 0 ) : x = x - 1 if pyxel . btn ( pyxel . KEY_DOWN ): if ( y < 120 ) : y = y + 1 if pyxel . btn ( pyxel . KEY_UP ): if ( y > 0 ) : y = y - 1 return x , y","title":"D\u00e9claration des variables et des fonctions"},{"location":"PYTHON/Premiers%20pas%20avec%20Pyxel%20-%20Premi%C3%A8re%20et%20Terminale/Tutoriel-07%20-%20Compl%C3%A9ments/#fonction-update","text":"Cette fonction update() est appel\u00e9 30 fois par seconde. def update (): \"\"\"mise \u00e0 jour des variables (30 fois par seconde)\"\"\" global vaisseau_x , vaisseau_y # mise \u00e0 jour de la position du vaisseau vaisseau_x , vaisseau_y = vaisseau_deplacement ( vaisseau_x , vaisseau_y ) Que fait cette instruction (affectation) ? vaisseau_x , vaisseau_y = vaisseau_deplacement ( vaisseau_x , vaisseau_y ) L'appel de la fonction vaisseau_deplacement(vaisseau_x, vaisseau_y) avec pour arguments les valeurs des variables vaisseau_x et vaisseau_y et renvoie les valeurs modifi\u00e9es suivant certaines touches du clavier. Ces valeurs renvoy\u00e9es sont affect\u00e9es aux variables vaisseau_x et vaisseau_y . Les valeurs des variables vaisseau_x et vaisseau_y sont modifi\u00e9es 30 fois par seconde suivant certaines touches du clavier.","title":"Fonction update()"},{"location":"PYTHON/Premiers%20pas%20avec%20Pyxel%20-%20Premi%C3%A8re%20et%20Terminale/Tutoriel-07%20-%20Compl%C3%A9ments/#fonction-draw","text":"Enfin le dessin ! Pour l'instant il n'y a pas encore de vaisseau. On a cr\u00e9\u00e9 deux variables vaisseau_x et vaisseau_y qui sont modifi\u00e9es par l'appel de la fonction update() 30 fois par seconde permettant de r\u00e9aliser cette instruction. vaisseau_x , vaisseau_y = vaisseau_deplacement ( vaisseau_x , vaisseau_y ) Cette fonction draw() est appel\u00e9 30 fois par seconde. def draw (): \"\"\"cr\u00e9ation des objets (30 fois par seconde)\"\"\" # vide la fenetre pyxel . cls ( 0 ) # vaisseau (carre 8x8) pyxel . rect ( vaisseau_x , vaisseau_y , 8 , 8 , 1 ) L'instruction pyxel.rect(vaisseau_x, vaisseau_y, 8, 8, 1) permet de dessiner un rectangle ayant comme coordonn\u00e9es coin gauche les valeurs des variables vaisseau_x et vaisseau_y , de largeur 8, de hauteur 8 et de couleur 1. A quoi sert l'instruction python pyxel.cls(0) ? La commenter et essayer ? La modifier en python pyxel.cls(3) et essayer ? La modifier en python pyxel.cls(1) et essayer ? 30 fois par seconde deux actions sont r\u00e9alis\u00e9es : la fen\u00eatre graphique est remplie d'une couleur on dessine une rectangle Cela donne l'illusion d'un mouvement comme au cin\u00e9ma.","title":"Fonction draw()"},{"location":"PYTHON/Premiers%20pas%20avec%20Pyxel%20-%20Premi%C3%A8re%20et%20Terminale/Tutoriel-07%20-%20Compl%C3%A9ments/#tutoriel-02","text":"Halo autour du tir pyxel . rectb ( tir [ 0 ] - 1 , tir [ 1 ] - 1 , 3 , 6 , 3 ) Tir sous forme cercle avec halo pyxel . circ ( tir [ 0 ], tir [ 1 ], 2 , 3 ) pyxel . circb ( tir [ 0 ], tir [ 1 ], 3 , 9 ) Tir sous forme cercle avec halo clignotant import random pyxel . circb ( tir [ 0 ], tir [ 1 ], 3 , random . randint ( 1 , 10 ))","title":"Tutoriel #02"},{"location":"PYTHON/Premiers%20pas%20avec%20Pyxel%20-%20Premi%C3%A8re%20et%20Terminale/Tutoriel-07%20-%20Compl%C3%A9ments/#tutoriel-03","text":"Mettre en parall\u00e8le la cr\u00e9ation des tirs et des ennemis. Utilisation de listes pour enregistrer les coordonn\u00e9es sous la forme de liste. Ajout de valeurs (coordonn\u00e9es) par rapport au vaisseau par appui sur une touche. Ajout de valeurs (coordonn\u00e9es) al\u00e9atoire pour l'abscisse suivant une dur\u00e9e. def tirs_creation ( x , y , tirs_liste ): \"\"\"cr\u00e9ation d'un tir avec la barre d'espace\"\"\" # btnr pour eviter les tirs multiples if pyxel . btnr ( pyxel . KEY_SPACE ): tirs_liste . append ([ x + 4 , y - 4 ]) return tirs_liste def ennemis_creation ( ennemis_liste ): \"\"\"cr\u00e9ation al\u00e9atoire des ennemis\"\"\" # un ennemi par seconde if ( pyxel . frame_count % 30 == 0 ): ennemis_liste . append ([ random . randint ( 0 , 120 ), 0 ]) return ennemis_liste Mise \u00e0 jour des valeurs des diff\u00e9rentes listes suivant des conditions. def tirs_deplacement ( tirs_liste ): \"\"\"d\u00e9placement des tirs vers le haut et suppression s'ils sortent du cadre\"\"\" for tir in tirs_liste : tir [ 1 ] -= 1 if tir [ 1 ] <- 8 : tirs_liste . remove ( tir ) return tirs_liste def ennemis_deplacement ( ennemis_liste ): \"\"\"d\u00e9placement des ennemis vers le haut et suppression s'ils sortent du cadre\"\"\" for ennemi in ennemis_liste : ennemi [ 1 ] += 1 if ennemi [ 1 ] > 128 : ennemis_liste . remove ( ennemi ) return ennemis_liste","title":"Tutoriel #03"},{"location":"PYTHON/Premiers%20pas%20avec%20Pyxel%20-%20Premi%C3%A8re%20et%20Terminale/Tutoriel-07%20-%20Compl%C3%A9ments/#fonction-update_1","text":"La fonction update() est appel\u00e9 30 fois par seconde permettant la mise \u00e0 jour des diff\u00e9rentes variables. def update (): \"\"\"mise \u00e0 jour des variables (30 fois par seconde)\"\"\" global vaisseau_x , vaisseau_y , tirs_liste , ennemis_liste # mise \u00e0 jour de la position du vaisseau vaisseau_x , vaisseau_y = vaisseau_deplacement ( vaisseau_x , vaisseau_y ) # creation des tirs en fonction de la position du vaisseau tirs_liste = tirs_creation ( vaisseau_x , vaisseau_y , tirs_liste ) # mise a jour des positions des tirs tirs_liste = tirs_deplacement ( tirs_liste ) # creation des ennemis ennemis_liste = ennemis_creation ( ennemis_liste ) # mise a jour des positions des ennemis ennemis_liste = ennemis_deplacement ( ennemis_liste )","title":"Fonction update()"},{"location":"PYTHON/Premiers%20pas%20avec%20Pyxel%20-%20Premi%C3%A8re%20et%20Terminale/Tutoriel-07%20-%20Compl%C3%A9ments/#fonction-draw_1","text":"Enfin le dessin ! La fonction draw() est appel\u00e9 30 fois par seconde. def draw (): \"\"\"cr\u00e9ation des objets (30 fois par seconde)\"\"\" # vide la fenetre pyxel . cls ( 0 ) # vaisseau (carre 8x8) pyxel . rect ( vaisseau_x , vaisseau_y , 8 , 8 , 1 ) # tirs for tir in tirs_liste : pyxel . rect ( tir [ 0 ], tir [ 1 ], 1 , 4 , 10 ) # ennemis for ennemi in ennemis_liste : pyxel . rect ( ennemi [ 0 ], ennemi [ 1 ], 8 , 8 , 8 ) Auteur : Charles Poulmaire - Twitter","title":"Fonction draw()"},{"location":"PYTHON/Tutoriel%20d%C3%A9taill%C3%A9%20-%20Terminale/Cr%C3%A9er%20une%20application%20Pyxel/","text":"Cr\u00e9er une application Pyxel 1. D\u00e9placer un carr\u00e9 avec les touches de directions Apr\u00e8s avoir import\u00e9 le module Pyxel dans votre script Python, on cr\u00e9e une classe Jeu, pour regrouper l\u2019ensemble des attributs et m\u00e9thodes n\u00e9cessaires. Utiliser une classe a l\u2019avantage de remplacer des variables globales par des attributs. Cette classe doit contenir les m\u00e9thodes draw() et update() . La m\u00e9thode draw() cr\u00e9e et positionne les objets, alors que la m\u00e9thode update() met \u00e0 jour les variables. A l\u2019int\u00e9rieur du constructeur de la classe, on sp\u00e9cifie d\u2019abord la taille de la fen\u00eatre avec la fonction init() : # taille de la fenetre 128x128 pixels # ne pas modifier pyxel . init ( 128 , 128 , title = \"Nuit du c0de\" ) On lance l\u2019application Pyxel avec la fonction run qui cr\u00e9e deux processus bas\u00e9s sur les m\u00e9thodes draw() et update() : pyxel . run ( self . update , self . draw ) Cette instruction doit \u00eatre la derni\u00e8re du constructeur. La cr\u00e9ation d\u2019une instance de la classe permet de lancer le jeu. Pour d\u00e9placer un objet, on v\u00e9rifie modifie ses coordonn\u00e9es dans la m\u00e9thode update(). Ici on les modifie \u00e0 l\u2019aide du clavier, en v\u00e9rifiant si une touche est press\u00e9e (dans cet exemple, la touche droite et le touche gauche) : if pyxel . btn ( pyxel . KEY_RIGHT ) and self . vaisseau_x < 120 : self . vaisseau_x += 1 if pyxel . btn ( pyxel . KEY_LEFT ) and self . vaisseau_x > 0 : self . vaisseau_x += - 1 Il ne reste plus qu\u2019\u00e0 afficher le carr\u00e9 avec ses nouvelles coordonn\u00e9es gr\u00e2ce \u00e0 cette instruction dans la m\u00e9thode draw() : # vaisseau (carre 8x8) pyxel . rect ( self . vaisseau_x , self . vaisseau_y , 8 , 8 , 1 ) Lancer le script tutoriel1.py . Modifier le script pour le d\u00e9placer selon l\u2019axe des y. Les attributs mouse_x et mouse_y du module pyxel permettent de connaitre la position actuelle de la souris. Modifier le script pour contr\u00f4ler le carr\u00e9 avec la souris 2. Ajouter des tirs Un tir est caract\u00e9ris\u00e9 par ses coordonn\u00e9es. Cr\u00e9er un tir signifie ajouter un couple de coordonn\u00e9es dans la liste des tirs. if pyxel . btnr ( pyxel . KEY_SPACE ): self . tirs_liste . append ([ self . vaisseau_x + 4 , self . vaisseau_y - 4 ]) Les coordonn\u00e9es du tir sont d\u00e9termin\u00e9es \u00e0 partir de celles du vaisseau, sachant que ces coordonn\u00e9es correspondent au coin en haut \u00e0 gauche. On d\u00e9place ensuite d\u2019un pixel le tir jusqu\u2019\u00e0 ce qu\u2019il sorte de l\u2019\u00e9cran. Il suffit alors de le retirer de la liste des tirs pour le supprimer. for tir in self . tirs_liste : tir [ 1 ] -= 1 if tir [ 1 ] <- 8 : self . tirs_liste . remove ( tir ) Lancer le script tutoriel2.py . 3. Ajouter des ennemis Les images sont affich\u00e9es \u00e0 l\u2019\u00e9cran \u00e0 raison de 30 images par secondes. L\u2019attribut frame_count du module pyxel comptabilise le nombre d\u2019images affich\u00e9es depuis le d\u00e9but du jeu. Ainsi, pour cr\u00e9er un ennemi toute les secondes, on v\u00e9rifie que le nombres d\u2019images est un multiple de 30. La cr\u00e9ation des ennemis repose sur le m\u00eame principe que celui des tirs, mais on utilise la fonction randint() du module random pour les cr\u00e9er de fa\u00e7on al\u00e9atoire selon l\u2019axe des x. # un ennemi par seconde if ( pyxel . frame_count % 30 == 0 ): self . ennemis_liste . append ([ random . randint ( 0 , 120 ), 0 ]) Lancer le script tutoriel3.py . 4. Ajouter les collisions Pour le cas de la collision d\u2019un tir avec un ennemi, la d\u00e9tection est simple : la coordonn\u00e9e en y doit \u00eatre inf\u00e9rieure \u00e0 ye \u2013 8, et la coordonn\u00e9e en x doit \u00eatre comprise entre xe et xe + 8. Pour d\u00e9tecter une collision entre un ennemi et un vaisseau, il faut consid\u00e9rer deux cas de figure (en ne consid\u00e9rant pour l\u2019instant que l\u2019axe des x) : A partir de ces figures, on en d\u00e9duit deux conditions : il faut le bord gauche du vaisseau soit inf\u00e9rieur \u00e0 xe + 8, et le bord droit sup\u00e9rieur \u00e0 xe. On applique le m\u00eame raisonnement sur l\u2019axe des y. Gr\u00e2ce aux collisions il est possible de mettre une condition d\u2019\u00e9chec avec un \u00e9cran de fin de jeu. La m\u00e9thode text() permet d\u2019afficher un texte aux coordonn\u00e9es sp\u00e9cifi\u00e9es (on peut \u00e9galement pr\u00e9ciser le nombre de vie pendant la partie). # si le vaisseau possede des vies le jeu continue if self . vaisseau . vies > 0 : ... # sinon: GAME OVER else : pyxel . text ( 50 , 64 , 'GAME OVER' , 7 ) Lancer le script tutoriel4.py 5. Ajouter les explosions lors des collisions Pour les explosions, on proc\u00e8de comme pour les tirs. Cependant, en plus des coordonn\u00e9es, on ajoute un troisi\u00e8me param\u00e8tre. C\u2019est ce param\u00e8tre qui permettra de cr\u00e9er des cercles dont le rayon et la couleur \u00e9volue. Lancer le script tutoriel5.py . 6. Ajouter des images Une tuile (tile en anglais) est un \u00e9l\u00e9ment graphique d'un jeu vid\u00e9o, constitu\u00e9 de petites images (en g\u00e9n\u00e9ral) carr\u00e9es dispos\u00e9es sur une grille. Une tuile peut repr\u00e9senter un sprite ou un \u00e9l\u00e9ment de d\u00e9cor, avec lequel on peut interagir ou non. L'ensemble complet des tuiles disponibles pour une utilisation dans une zone de jeu est appel\u00e9 un jeu de tuiles (ou tileset en anglais). L\u2019\u00e9diteur Pyxel peut cr\u00e9er des images et des sons utilisables dans des applications Pyxel. (voir la documentation Pyxel) Lors de l'initialisation du jeu, il est n\u00e9cessaire de charger en m\u00e9moire le fichier ressource . # chargement des images pyxel . load ( \"images.pyxres\" ) On peut ensuite placer l\u2019image \u00e0 l\u2019\u00e9cran, \u00e0 la place du carr\u00e9 initial : # vaisseau (carre 8x8) pyxel . blt ( self . x , self . y , 0 , 0 , 0 , 8 , 8 ) Si les dimensions de l\u2019image sont indiqu\u00e9es comme n\u00e9gatives, la copie de l\u2019image sera invers\u00e9e horizontalement et/ou verticalement. Il est \u00e9galement possible de sp\u00e9cifier une couleur transparente, qui ne sera donc pas dessiner \u00e0 l\u2019\u00e9cran. On a choisi ici la couleur noire (code : 0), initialis\u00e9 dans la constante TRANSPARENT_COLOR . Lancer le script tutoriel6.py . 7. Utiliser la POO Il est \u00e9galement possible de cr\u00e9er des instances de classes pour d\u00e9crire les diff\u00e9rents \u00e9l\u00e9ments du jeu. En soi, le fonctionnement est identique ; par contre, cela permet de regrouper dans un m\u00eame objet les caract\u00e9ristiques et les comportements de l\u2019objet. Par exemple, un objet Tir va regrouper ses coordonn\u00e9es, ainsi que la mani\u00e8re de le dessiner, de la d\u00e9placer et la gestion des collisions avec les ennemis. On peut remarquer qu\u2019un troisi\u00e8me attribut a \u00e9t\u00e9 rajout\u00e9 : il s\u2019agit de l\u2019attribut alive , initialis\u00e9 \u00e0 True , qui permet de d\u00e9terminer si l\u2019objet doit continuer \u00e0 \u00eatre afficher ou s\u2019il doit \u00eatre supprimer. def deplacement ( self ): self . y -= 1 if self . y < - 8 : self . alive = False Les objets qui ne sont plus \u00ab vivants \u00bb sont alors supprim\u00e9s des listes \u00e0 dessiner. for tir in self . tirs_liste : tir . deplacement () if not tir . alive : self . tirs_liste . remove ( tir ) Lancer le script tutoriel7.py . 8. Animer les sprites Pour animer les sprites, on va utiliser plusieurs images du pav\u00e9 pour un seul sprite. L\u2019enchainement des images donne l\u2019impression de mouvement. Dans le script tutoriel8.py, on utilise l\u2019attribut pyxel.frame_count pour modifier l\u2019image toutes les 1/10\u00e8me de seconde. On utilise la variable coef pour choisir l\u2019image. #Change l'aspect tous les 1/10 de secondes #coef peut vaaloir 0,1 ou 2 coef = pyxel . frame_count // 3 % 3 pyxel . blt ( self . x , self . y , 0 , 0 , 8 + 8 * coef , 8 , 8 ) Lancer le script tutoriel8.py . 9. Ajouter du son Il est possible de rajouter des sons et des musiques au jeu. Ces derniers peuvent \u00eatre cr\u00e9\u00e9s \u00e0 partir de l\u2019\u00e9diteur de ressources. On peut charger les fichiers ressources gr\u00e2ce \u00e0 la m\u00e9thode load(). Le fichier peut \u00eatre charg\u00e9 en entier, ou partiellement. Dans ce cas on sp\u00e9cifie quelles parties charg\u00e9es. La m\u00e9thode playm() permet de lancer une musique en continu. # chargement des images et des sons pyxel . load ( \"images.pyxres\" , True , True , False , False ) pyxel . load ( \"sons.pyxres\" , False , False , True , True ) #Lancement de la musique pyxel . playm ( 0 , loop = True ) On peut \u00e9galement \u00e9mettre des bruitages (ici, le son num\u00e9ro 1) : #lancement d'un bruitage pyxel . play ( 0 , 1 ) Lancer le script tutoriel9.py . 10. Ajouter et faire d\u00e9filer un d\u00e9cor Une tilemap (litt\u00e9ralement une \"carte de tuile\") est une grille utilis\u00e9e pour cr\u00e9er la disposition/le fond graphique d'un jeu. L'\u00e9cran est ainsi repr\u00e9sent\u00e9 par une grille compos\u00e9e de nombreuses cases, sur lesquelles sont appliqu\u00e9es une image par case. Il est alors possible de cr\u00e9er un fond au jeu, compos\u00e9 des \u00e9l\u00e9ments du jeu de tuiles On peut \u00e9galement superposer les d\u00e9cor afin de cr\u00e9er une impression de profondeur. En d\u00e9but de la m\u00e9thode draw() , on chargera d\u2019abord le fond, puis le d\u00e9cor de premier plan. Ce d\u00e9cor peut \u00eatre statique, mais il est \u00e9galement possible de r\u00e9aliser un d\u00e9filement. Ce d\u00e9filement peut \u00eatre automatique (par exemple \u00e0 raison de 1 px/s) ou li\u00e9 aux d\u00e9placements du personnage. pyxel . camera () pyxel . bltm ( 0 , 0 , 0 , 192 , ( self . scroll_y // 4 ) % 128 , 128 , 128 ) pyxel . bltm ( 0 , 0 , 0 , 0 , self . scroll_y , 128 , 128 , TRANSPARENT_COLOR ) Lancer le script tutoriel10.py . 11. Interagir avec le d\u00e9cor A l\u2019int\u00e9rieur du jeu de tuiles, chaque tuile est rep\u00e9r\u00e9e par des coordonn\u00e9es. Ici, la fus\u00e9e se trouve aux coordonn\u00e9es (0, 0) et le monstre \u00e0 (0, 1). La carte peut \u00eatre consid\u00e9r\u00e9e comme une grille o\u00f9 chaque case contient une tuile (elle-m\u00eame identifi\u00e9e par ses coordonn\u00e9es dans le jeu de tuile). Ainsi chaque case de la carte mesure 8 pixels par 8. Il est donc possible de d\u00e9tecter des collisions entre le vaisseau et un ast\u00e9ro\u00efde du d\u00e9cor. Dans un premier temps on convertit les coordonn\u00e9es \u00e0 l\u2019\u00e9cran avec les coordonn\u00e9es de la carte, en prenant en comptant un \u00e9ventuel d\u00e9filement. #conversion entre les coordonn\u00e9es du \u00e0 l'\u00e9cran # et les coordonn\u00e9es de la carte x1 = self . x // 8 y1 = ( self . y + scroll ) // 8 Il faut ensuite prendre en compte que le vaisseau peut \u00eatre \u00e0 cheval sur plusieurs tuiles. # Le vaisseau peut potentiellement \u00eatre \u00e0 cheval sur 4 tuiles x2 = ( self . x + 8 - 1 ) // 8 y2 = ( self . y + scroll + 8 - 1 ) // 8 On peut ensuite d\u00e9tecter sur quelle tuile on se trouve gr\u00e2ce \u00e0 la m\u00e9thode pget() de l\u2019objet tilemap . La constante TUILE_ASTEROID est initialis\u00e9e aux coordonn\u00e9es de la tuile recherch\u00e9e, \u00e0 savoir (2, 1). #on parcours 1 \u00e0 4 tuiles for yi in range ( y1 , y2 + 1 ): for xi in range ( x1 , x2 + 1 ): tuile = pyxel . tilemap ( 0 ) . pget ( xi , yi ) if tuile == TUILE_ASTEROID : self . vies -= 1 #on efface la tuile pour ne pas qu'elle soit prise en compte deux fois pyxel . tilemap ( 0 ) . pset ( xi , yi , TUILE_ESPACE ) Une fois d\u00e9tect\u00e9e, on modifie la tuile pour ne pas qu\u2019elle soit prise en compte plusieurs fois gr\u00e2ce \u00e0 la m\u00e9thode pset() de l\u2019objet tilemap . A noter que cette modification n\u2019est pas d\u00e9finitive et n\u2019intervient que pour la carte charg\u00e9e en m\u00e9moire. Lancer le script tutoriel11.py . Cr\u00e9er la fonction detect_bonus() qui d\u00e9tecte le passage du vaisseau sur les bonus de gain de vie pr\u00e9sents dans le d\u00e9cor. 12. Placer des ennemis dans le d\u00e9cor Au lieu que les ennemis apparaissent de mani\u00e8re al\u00e9atoire, on peut vouloir qu\u2019ils apparaissent \u00e0 des endroits pr\u00e9cis du d\u00e9cor. Pour cela, il faut d\u00e9dier une tuile \u00e0 ce placement, puis on place des copies de cette tuile aux endroits de la carte o\u00f9 l\u2019on souhaite voir surgir les ennemis. A l\u2019initialisation du jeu, il est n\u00e9cessaire de rendre ces tuiles transparentes afin qu\u2019elles ne soient pas affich\u00e9es, par contre elles pourront toujours \u00eatre identifi\u00e9es par la m\u00e9thode pget() de l\u2019objet tilemap . # chargement des images pyxel . load ( \"images.pyxres\" ) pyxel . image ( 0 ) . rect ( 16 , 16 , 8 , 8 , TRANSPARENT_COLOR ) Lors du d\u00e9filement, on parcourt la carte (tout du moins la partie nouvellement affich\u00e9e) et on cr\u00e9e un ennemi aux coordonn\u00e9es de chaque tuile que l\u2019on trouve. tuile = pyxel . tilemap ( 0 ) . pget ( x , y ) if tuile == TUILE_MONSTRE : pyxel . tilemap ( 0 ) . pset ( x , y , TUILE_ESPACE ) self . ennemis_liste . append ([ x * 8 , y * 8 - y1 ]) Lancer le script tutoriel12.py . Auteur : Peio47","title":"Cr\u00e9er une application Pyxel"},{"location":"PYTHON/Tutoriel%20d%C3%A9taill%C3%A9%20-%20Terminale/Cr%C3%A9er%20une%20application%20Pyxel/#creer-une-application-pyxel","text":"","title":"Cr\u00e9er une application Pyxel"},{"location":"PYTHON/Tutoriel%20d%C3%A9taill%C3%A9%20-%20Terminale/Cr%C3%A9er%20une%20application%20Pyxel/#1-deplacer-un-carre-avec-les-touches-de-directions","text":"Apr\u00e8s avoir import\u00e9 le module Pyxel dans votre script Python, on cr\u00e9e une classe Jeu, pour regrouper l\u2019ensemble des attributs et m\u00e9thodes n\u00e9cessaires. Utiliser une classe a l\u2019avantage de remplacer des variables globales par des attributs. Cette classe doit contenir les m\u00e9thodes draw() et update() . La m\u00e9thode draw() cr\u00e9e et positionne les objets, alors que la m\u00e9thode update() met \u00e0 jour les variables. A l\u2019int\u00e9rieur du constructeur de la classe, on sp\u00e9cifie d\u2019abord la taille de la fen\u00eatre avec la fonction init() : # taille de la fenetre 128x128 pixels # ne pas modifier pyxel . init ( 128 , 128 , title = \"Nuit du c0de\" ) On lance l\u2019application Pyxel avec la fonction run qui cr\u00e9e deux processus bas\u00e9s sur les m\u00e9thodes draw() et update() : pyxel . run ( self . update , self . draw ) Cette instruction doit \u00eatre la derni\u00e8re du constructeur. La cr\u00e9ation d\u2019une instance de la classe permet de lancer le jeu. Pour d\u00e9placer un objet, on v\u00e9rifie modifie ses coordonn\u00e9es dans la m\u00e9thode update(). Ici on les modifie \u00e0 l\u2019aide du clavier, en v\u00e9rifiant si une touche est press\u00e9e (dans cet exemple, la touche droite et le touche gauche) : if pyxel . btn ( pyxel . KEY_RIGHT ) and self . vaisseau_x < 120 : self . vaisseau_x += 1 if pyxel . btn ( pyxel . KEY_LEFT ) and self . vaisseau_x > 0 : self . vaisseau_x += - 1 Il ne reste plus qu\u2019\u00e0 afficher le carr\u00e9 avec ses nouvelles coordonn\u00e9es gr\u00e2ce \u00e0 cette instruction dans la m\u00e9thode draw() : # vaisseau (carre 8x8) pyxel . rect ( self . vaisseau_x , self . vaisseau_y , 8 , 8 , 1 ) Lancer le script tutoriel1.py . Modifier le script pour le d\u00e9placer selon l\u2019axe des y. Les attributs mouse_x et mouse_y du module pyxel permettent de connaitre la position actuelle de la souris. Modifier le script pour contr\u00f4ler le carr\u00e9 avec la souris","title":"1. D\u00e9placer un carr\u00e9 avec les touches de directions"},{"location":"PYTHON/Tutoriel%20d%C3%A9taill%C3%A9%20-%20Terminale/Cr%C3%A9er%20une%20application%20Pyxel/#2-ajouter-des-tirs","text":"Un tir est caract\u00e9ris\u00e9 par ses coordonn\u00e9es. Cr\u00e9er un tir signifie ajouter un couple de coordonn\u00e9es dans la liste des tirs. if pyxel . btnr ( pyxel . KEY_SPACE ): self . tirs_liste . append ([ self . vaisseau_x + 4 , self . vaisseau_y - 4 ]) Les coordonn\u00e9es du tir sont d\u00e9termin\u00e9es \u00e0 partir de celles du vaisseau, sachant que ces coordonn\u00e9es correspondent au coin en haut \u00e0 gauche. On d\u00e9place ensuite d\u2019un pixel le tir jusqu\u2019\u00e0 ce qu\u2019il sorte de l\u2019\u00e9cran. Il suffit alors de le retirer de la liste des tirs pour le supprimer. for tir in self . tirs_liste : tir [ 1 ] -= 1 if tir [ 1 ] <- 8 : self . tirs_liste . remove ( tir ) Lancer le script tutoriel2.py .","title":"2. Ajouter des tirs"},{"location":"PYTHON/Tutoriel%20d%C3%A9taill%C3%A9%20-%20Terminale/Cr%C3%A9er%20une%20application%20Pyxel/#3-ajouter-des-ennemis","text":"Les images sont affich\u00e9es \u00e0 l\u2019\u00e9cran \u00e0 raison de 30 images par secondes. L\u2019attribut frame_count du module pyxel comptabilise le nombre d\u2019images affich\u00e9es depuis le d\u00e9but du jeu. Ainsi, pour cr\u00e9er un ennemi toute les secondes, on v\u00e9rifie que le nombres d\u2019images est un multiple de 30. La cr\u00e9ation des ennemis repose sur le m\u00eame principe que celui des tirs, mais on utilise la fonction randint() du module random pour les cr\u00e9er de fa\u00e7on al\u00e9atoire selon l\u2019axe des x. # un ennemi par seconde if ( pyxel . frame_count % 30 == 0 ): self . ennemis_liste . append ([ random . randint ( 0 , 120 ), 0 ]) Lancer le script tutoriel3.py .","title":"3. Ajouter des ennemis"},{"location":"PYTHON/Tutoriel%20d%C3%A9taill%C3%A9%20-%20Terminale/Cr%C3%A9er%20une%20application%20Pyxel/#4-ajouter-les-collisions","text":"Pour le cas de la collision d\u2019un tir avec un ennemi, la d\u00e9tection est simple : la coordonn\u00e9e en y doit \u00eatre inf\u00e9rieure \u00e0 ye \u2013 8, et la coordonn\u00e9e en x doit \u00eatre comprise entre xe et xe + 8. Pour d\u00e9tecter une collision entre un ennemi et un vaisseau, il faut consid\u00e9rer deux cas de figure (en ne consid\u00e9rant pour l\u2019instant que l\u2019axe des x) : A partir de ces figures, on en d\u00e9duit deux conditions : il faut le bord gauche du vaisseau soit inf\u00e9rieur \u00e0 xe + 8, et le bord droit sup\u00e9rieur \u00e0 xe. On applique le m\u00eame raisonnement sur l\u2019axe des y. Gr\u00e2ce aux collisions il est possible de mettre une condition d\u2019\u00e9chec avec un \u00e9cran de fin de jeu. La m\u00e9thode text() permet d\u2019afficher un texte aux coordonn\u00e9es sp\u00e9cifi\u00e9es (on peut \u00e9galement pr\u00e9ciser le nombre de vie pendant la partie). # si le vaisseau possede des vies le jeu continue if self . vaisseau . vies > 0 : ... # sinon: GAME OVER else : pyxel . text ( 50 , 64 , 'GAME OVER' , 7 ) Lancer le script tutoriel4.py","title":"4. Ajouter les collisions"},{"location":"PYTHON/Tutoriel%20d%C3%A9taill%C3%A9%20-%20Terminale/Cr%C3%A9er%20une%20application%20Pyxel/#5-ajouter-les-explosions-lors-des-collisions","text":"Pour les explosions, on proc\u00e8de comme pour les tirs. Cependant, en plus des coordonn\u00e9es, on ajoute un troisi\u00e8me param\u00e8tre. C\u2019est ce param\u00e8tre qui permettra de cr\u00e9er des cercles dont le rayon et la couleur \u00e9volue. Lancer le script tutoriel5.py .","title":"5. Ajouter les explosions lors des collisions"},{"location":"PYTHON/Tutoriel%20d%C3%A9taill%C3%A9%20-%20Terminale/Cr%C3%A9er%20une%20application%20Pyxel/#6-ajouter-des-images","text":"Une tuile (tile en anglais) est un \u00e9l\u00e9ment graphique d'un jeu vid\u00e9o, constitu\u00e9 de petites images (en g\u00e9n\u00e9ral) carr\u00e9es dispos\u00e9es sur une grille. Une tuile peut repr\u00e9senter un sprite ou un \u00e9l\u00e9ment de d\u00e9cor, avec lequel on peut interagir ou non. L'ensemble complet des tuiles disponibles pour une utilisation dans une zone de jeu est appel\u00e9 un jeu de tuiles (ou tileset en anglais). L\u2019\u00e9diteur Pyxel peut cr\u00e9er des images et des sons utilisables dans des applications Pyxel. (voir la documentation Pyxel) Lors de l'initialisation du jeu, il est n\u00e9cessaire de charger en m\u00e9moire le fichier ressource . # chargement des images pyxel . load ( \"images.pyxres\" ) On peut ensuite placer l\u2019image \u00e0 l\u2019\u00e9cran, \u00e0 la place du carr\u00e9 initial : # vaisseau (carre 8x8) pyxel . blt ( self . x , self . y , 0 , 0 , 0 , 8 , 8 ) Si les dimensions de l\u2019image sont indiqu\u00e9es comme n\u00e9gatives, la copie de l\u2019image sera invers\u00e9e horizontalement et/ou verticalement. Il est \u00e9galement possible de sp\u00e9cifier une couleur transparente, qui ne sera donc pas dessiner \u00e0 l\u2019\u00e9cran. On a choisi ici la couleur noire (code : 0), initialis\u00e9 dans la constante TRANSPARENT_COLOR . Lancer le script tutoriel6.py .","title":"6. Ajouter des images"},{"location":"PYTHON/Tutoriel%20d%C3%A9taill%C3%A9%20-%20Terminale/Cr%C3%A9er%20une%20application%20Pyxel/#7-utiliser-la-poo","text":"Il est \u00e9galement possible de cr\u00e9er des instances de classes pour d\u00e9crire les diff\u00e9rents \u00e9l\u00e9ments du jeu. En soi, le fonctionnement est identique ; par contre, cela permet de regrouper dans un m\u00eame objet les caract\u00e9ristiques et les comportements de l\u2019objet. Par exemple, un objet Tir va regrouper ses coordonn\u00e9es, ainsi que la mani\u00e8re de le dessiner, de la d\u00e9placer et la gestion des collisions avec les ennemis. On peut remarquer qu\u2019un troisi\u00e8me attribut a \u00e9t\u00e9 rajout\u00e9 : il s\u2019agit de l\u2019attribut alive , initialis\u00e9 \u00e0 True , qui permet de d\u00e9terminer si l\u2019objet doit continuer \u00e0 \u00eatre afficher ou s\u2019il doit \u00eatre supprimer. def deplacement ( self ): self . y -= 1 if self . y < - 8 : self . alive = False Les objets qui ne sont plus \u00ab vivants \u00bb sont alors supprim\u00e9s des listes \u00e0 dessiner. for tir in self . tirs_liste : tir . deplacement () if not tir . alive : self . tirs_liste . remove ( tir ) Lancer le script tutoriel7.py .","title":"7. Utiliser la POO"},{"location":"PYTHON/Tutoriel%20d%C3%A9taill%C3%A9%20-%20Terminale/Cr%C3%A9er%20une%20application%20Pyxel/#8-animer-les-sprites","text":"Pour animer les sprites, on va utiliser plusieurs images du pav\u00e9 pour un seul sprite. L\u2019enchainement des images donne l\u2019impression de mouvement. Dans le script tutoriel8.py, on utilise l\u2019attribut pyxel.frame_count pour modifier l\u2019image toutes les 1/10\u00e8me de seconde. On utilise la variable coef pour choisir l\u2019image. #Change l'aspect tous les 1/10 de secondes #coef peut vaaloir 0,1 ou 2 coef = pyxel . frame_count // 3 % 3 pyxel . blt ( self . x , self . y , 0 , 0 , 8 + 8 * coef , 8 , 8 ) Lancer le script tutoriel8.py .","title":"8. Animer les sprites"},{"location":"PYTHON/Tutoriel%20d%C3%A9taill%C3%A9%20-%20Terminale/Cr%C3%A9er%20une%20application%20Pyxel/#9-ajouter-du-son","text":"Il est possible de rajouter des sons et des musiques au jeu. Ces derniers peuvent \u00eatre cr\u00e9\u00e9s \u00e0 partir de l\u2019\u00e9diteur de ressources. On peut charger les fichiers ressources gr\u00e2ce \u00e0 la m\u00e9thode load(). Le fichier peut \u00eatre charg\u00e9 en entier, ou partiellement. Dans ce cas on sp\u00e9cifie quelles parties charg\u00e9es. La m\u00e9thode playm() permet de lancer une musique en continu. # chargement des images et des sons pyxel . load ( \"images.pyxres\" , True , True , False , False ) pyxel . load ( \"sons.pyxres\" , False , False , True , True ) #Lancement de la musique pyxel . playm ( 0 , loop = True ) On peut \u00e9galement \u00e9mettre des bruitages (ici, le son num\u00e9ro 1) : #lancement d'un bruitage pyxel . play ( 0 , 1 ) Lancer le script tutoriel9.py .","title":"9. Ajouter du son"},{"location":"PYTHON/Tutoriel%20d%C3%A9taill%C3%A9%20-%20Terminale/Cr%C3%A9er%20une%20application%20Pyxel/#10-ajouter-et-faire-defiler-un-decor","text":"Une tilemap (litt\u00e9ralement une \"carte de tuile\") est une grille utilis\u00e9e pour cr\u00e9er la disposition/le fond graphique d'un jeu. L'\u00e9cran est ainsi repr\u00e9sent\u00e9 par une grille compos\u00e9e de nombreuses cases, sur lesquelles sont appliqu\u00e9es une image par case. Il est alors possible de cr\u00e9er un fond au jeu, compos\u00e9 des \u00e9l\u00e9ments du jeu de tuiles On peut \u00e9galement superposer les d\u00e9cor afin de cr\u00e9er une impression de profondeur. En d\u00e9but de la m\u00e9thode draw() , on chargera d\u2019abord le fond, puis le d\u00e9cor de premier plan. Ce d\u00e9cor peut \u00eatre statique, mais il est \u00e9galement possible de r\u00e9aliser un d\u00e9filement. Ce d\u00e9filement peut \u00eatre automatique (par exemple \u00e0 raison de 1 px/s) ou li\u00e9 aux d\u00e9placements du personnage. pyxel . camera () pyxel . bltm ( 0 , 0 , 0 , 192 , ( self . scroll_y // 4 ) % 128 , 128 , 128 ) pyxel . bltm ( 0 , 0 , 0 , 0 , self . scroll_y , 128 , 128 , TRANSPARENT_COLOR ) Lancer le script tutoriel10.py .","title":"10. Ajouter et faire d\u00e9filer un d\u00e9cor"},{"location":"PYTHON/Tutoriel%20d%C3%A9taill%C3%A9%20-%20Terminale/Cr%C3%A9er%20une%20application%20Pyxel/#11-interagir-avec-le-decor","text":"A l\u2019int\u00e9rieur du jeu de tuiles, chaque tuile est rep\u00e9r\u00e9e par des coordonn\u00e9es. Ici, la fus\u00e9e se trouve aux coordonn\u00e9es (0, 0) et le monstre \u00e0 (0, 1). La carte peut \u00eatre consid\u00e9r\u00e9e comme une grille o\u00f9 chaque case contient une tuile (elle-m\u00eame identifi\u00e9e par ses coordonn\u00e9es dans le jeu de tuile). Ainsi chaque case de la carte mesure 8 pixels par 8. Il est donc possible de d\u00e9tecter des collisions entre le vaisseau et un ast\u00e9ro\u00efde du d\u00e9cor. Dans un premier temps on convertit les coordonn\u00e9es \u00e0 l\u2019\u00e9cran avec les coordonn\u00e9es de la carte, en prenant en comptant un \u00e9ventuel d\u00e9filement. #conversion entre les coordonn\u00e9es du \u00e0 l'\u00e9cran # et les coordonn\u00e9es de la carte x1 = self . x // 8 y1 = ( self . y + scroll ) // 8 Il faut ensuite prendre en compte que le vaisseau peut \u00eatre \u00e0 cheval sur plusieurs tuiles. # Le vaisseau peut potentiellement \u00eatre \u00e0 cheval sur 4 tuiles x2 = ( self . x + 8 - 1 ) // 8 y2 = ( self . y + scroll + 8 - 1 ) // 8 On peut ensuite d\u00e9tecter sur quelle tuile on se trouve gr\u00e2ce \u00e0 la m\u00e9thode pget() de l\u2019objet tilemap . La constante TUILE_ASTEROID est initialis\u00e9e aux coordonn\u00e9es de la tuile recherch\u00e9e, \u00e0 savoir (2, 1). #on parcours 1 \u00e0 4 tuiles for yi in range ( y1 , y2 + 1 ): for xi in range ( x1 , x2 + 1 ): tuile = pyxel . tilemap ( 0 ) . pget ( xi , yi ) if tuile == TUILE_ASTEROID : self . vies -= 1 #on efface la tuile pour ne pas qu'elle soit prise en compte deux fois pyxel . tilemap ( 0 ) . pset ( xi , yi , TUILE_ESPACE ) Une fois d\u00e9tect\u00e9e, on modifie la tuile pour ne pas qu\u2019elle soit prise en compte plusieurs fois gr\u00e2ce \u00e0 la m\u00e9thode pset() de l\u2019objet tilemap . A noter que cette modification n\u2019est pas d\u00e9finitive et n\u2019intervient que pour la carte charg\u00e9e en m\u00e9moire. Lancer le script tutoriel11.py . Cr\u00e9er la fonction detect_bonus() qui d\u00e9tecte le passage du vaisseau sur les bonus de gain de vie pr\u00e9sents dans le d\u00e9cor.","title":"11. Interagir avec le d\u00e9cor"},{"location":"PYTHON/Tutoriel%20d%C3%A9taill%C3%A9%20-%20Terminale/Cr%C3%A9er%20une%20application%20Pyxel/#12-placer-des-ennemis-dans-le-decor","text":"Au lieu que les ennemis apparaissent de mani\u00e8re al\u00e9atoire, on peut vouloir qu\u2019ils apparaissent \u00e0 des endroits pr\u00e9cis du d\u00e9cor. Pour cela, il faut d\u00e9dier une tuile \u00e0 ce placement, puis on place des copies de cette tuile aux endroits de la carte o\u00f9 l\u2019on souhaite voir surgir les ennemis. A l\u2019initialisation du jeu, il est n\u00e9cessaire de rendre ces tuiles transparentes afin qu\u2019elles ne soient pas affich\u00e9es, par contre elles pourront toujours \u00eatre identifi\u00e9es par la m\u00e9thode pget() de l\u2019objet tilemap . # chargement des images pyxel . load ( \"images.pyxres\" ) pyxel . image ( 0 ) . rect ( 16 , 16 , 8 , 8 , TRANSPARENT_COLOR ) Lors du d\u00e9filement, on parcourt la carte (tout du moins la partie nouvellement affich\u00e9e) et on cr\u00e9e un ennemi aux coordonn\u00e9es de chaque tuile que l\u2019on trouve. tuile = pyxel . tilemap ( 0 ) . pget ( x , y ) if tuile == TUILE_MONSTRE : pyxel . tilemap ( 0 ) . pset ( x , y , TUILE_ESPACE ) self . ennemis_liste . append ([ x * 8 , y * 8 - y1 ]) Lancer le script tutoriel12.py . Auteur : Peio47","title":"12. Placer des ennemis dans le d\u00e9cor"},{"location":"SCRATCH/01-introduction/","text":"INTRODUCTION Pour pr\u00e9parer la Nuit du c0de avec les \u00e9l\u00e8ves, voici plusieurs ressources qui permettent de mettre en place des s\u00e9ances de d\u00e9couverte / approfondissement de Scratch. Ces ressources (et de tr\u00e8s nombreuses autres pour les math\u00e9matiques) ont \u00e9t\u00e9 cr\u00e9\u00e9es par Jean-Yves Labouche qui a \u00e9t\u00e9 responsable de l'organisation de la Nuit du c0de pendant plusieurs ann\u00e9es. Elles sont publi\u00e9es sur son site . Vous trouverez ci-dessous la listes des ressources compos\u00e9es de: 18 tutoriels vid\u00e9o 4 exercices d'entra\u00eenement ou de s\u00e9lection","title":"INTRODUCTION"},{"location":"SCRATCH/01-introduction/#introduction","text":"Pour pr\u00e9parer la Nuit du c0de avec les \u00e9l\u00e8ves, voici plusieurs ressources qui permettent de mettre en place des s\u00e9ances de d\u00e9couverte / approfondissement de Scratch. Ces ressources (et de tr\u00e8s nombreuses autres pour les math\u00e9matiques) ont \u00e9t\u00e9 cr\u00e9\u00e9es par Jean-Yves Labouche qui a \u00e9t\u00e9 responsable de l'organisation de la Nuit du c0de pendant plusieurs ann\u00e9es. Elles sont publi\u00e9es sur son site . Vous trouverez ci-dessous la listes des ressources compos\u00e9es de: 18 tutoriels vid\u00e9o 4 exercices d'entra\u00eenement ou de s\u00e9lection","title":"INTRODUCTION"},{"location":"SCRATCH/02-videos/","text":"TUTORIELS VID\u00c9O 18 tutoriels au format vid\u00e9o","title":"TUTORIELS VID\u00c9O"},{"location":"SCRATCH/02-videos/#tutoriels-video","text":"18 tutoriels au format vid\u00e9o","title":"TUTORIELS VID\u00c9O"},{"location":"SCRATCH/03-entrainements/","text":"EXERCICES D'ENTRA\u00ceNEMENT OU DE S\u00c9LECTION 4 exercices complets \ud83d\udd79\ufe0f Duel dans le cosmos ouvrir Dans cet univers de jeu, il y a 7 lutins \u00e0 utiliser: 2 astronautes (blanc et orange) 2 lasers (vert et rouge) 1 explosion 1 lutin de texte et 2 de chiffres Les d\u00e9placements de l\u2019astronautes blanc sont d\u00e9j\u00e0 cod\u00e9s, vous n\u2019avez pas \u00e0 les modifier. Pour l\u2019astronaute orange, il y a aussi une base pour les d\u00e9placements qu\u2019il faudra compl\u00e9ter. Le jeu est simple : le joueur (astronaute blanc) doit tirer sur l\u2019astronaute orange sans se faire tirer dessus par celui-ci. Documents fournis: L'univers de jeu (fichier Scratch pour les \u00e9l\u00e8ves) La fiche de consigne Une grille d'\u00e9valuation \ud83d\udd79\ufe0f La cl\u00e9 des champs ouvrir Dans cet univers de jeu, il y a 14 lutins. Attention ! Vous n\u2019avez pas de code \u00e0 \u00e9crire pour l\u2019\u00e9chelle, le sol, ni les deux plates-formes. Le jeu est simple : l\u2019extraterrestre vert (joueur) doit aller chercher la clef sur la plate-forme pour ouvrir la porte. Il doit \u00e9viter les boules de feu envoy\u00e9es par la bernacle, l\u2019abeille et ne pas toucher aux pointes. Documents fournis: L'univers de jeu (fichier Scratch pour les \u00e9l\u00e8ves) La fiche de consigne Une grille d'\u00e9valuation \ud83d\udd79\ufe0f Le tr\u00e9sor de Piggy ouvrir Dans cet univers de jeu, il y a 7 lutins \u00e0 animer: Piggy, le cochon ail\u00e9 qui sera dirig\u00e9 par le joueur Des obstacles (scie, pi\u00e8ge, poing et masse) Une pi\u00e8ce Un coffre Il y a \u00e9galement un lutin \u00ab texte \u00bb et un autre qui contient les sons. Le jeu \u00e0 cr\u00e9er est simple : Piggy doit r\u00e9cup\u00e9rer la pi\u00e8ce et l\u2019apporter dans le coffre tout en \u00e9vitant les obstacles, tous mortels. Les lutins ont beaucoup de costumes qu\u2019il faudra bien utiliser. Documents fournis : L'univers de jeu (fichier Scratch pour les \u00e9l\u00e8ves) La fiche de consigne Une grille d'\u00e9valuation \ud83d\udd79\ufe0f Flappy Piggy ouvrir Dans cet univers de jeu, il y a 8 lutins \u00e0 utiliser : Piggy, le cochon ail\u00e9 qui sera dirig\u00e9 par le joueur ; des tuyaux (un seul lutin) ; deux lutins \u00ab sol \u00bb ; un lutin \u00ab Play \u00bb ; deux lutins \u00ab chiffres \u00bb pour afficher le score ; un lutin texte \u00ab Game over \u00bb. Chaque lutin contient les 4 sons \u00e0 disposition pour ce jeu. Le jeu \u00e0 cr\u00e9er est simple \u00e0 jouer, mais assez technique \u00e0 coder : Piggy doit passer entre les tuyaux sans les percuter. Documents fournis: L'univers de jeu (fichier Scratch pour les \u00e9l\u00e8ves) La fiche de consigne Une grille d'\u00e9valuation","title":"EXERCICES D'ENTRA\u00ceNEMENT OU DE S\u00c9LECTION"},{"location":"SCRATCH/03-entrainements/#exercices-dentrainement-ou-de-selection","text":"4 exercices complets","title":"EXERCICES D'ENTRA\u00ceNEMENT OU DE S\u00c9LECTION"},{"location":"SCRATCH/03-entrainements/#duel-dans-le-cosmos","text":"ouvrir Dans cet univers de jeu, il y a 7 lutins \u00e0 utiliser: 2 astronautes (blanc et orange) 2 lasers (vert et rouge) 1 explosion 1 lutin de texte et 2 de chiffres Les d\u00e9placements de l\u2019astronautes blanc sont d\u00e9j\u00e0 cod\u00e9s, vous n\u2019avez pas \u00e0 les modifier. Pour l\u2019astronaute orange, il y a aussi une base pour les d\u00e9placements qu\u2019il faudra compl\u00e9ter. Le jeu est simple : le joueur (astronaute blanc) doit tirer sur l\u2019astronaute orange sans se faire tirer dessus par celui-ci. Documents fournis: L'univers de jeu (fichier Scratch pour les \u00e9l\u00e8ves) La fiche de consigne Une grille d'\u00e9valuation","title":"\ud83d\udd79\ufe0f Duel dans le cosmos"},{"location":"SCRATCH/03-entrainements/#la-cle-des-champs","text":"ouvrir Dans cet univers de jeu, il y a 14 lutins. Attention ! Vous n\u2019avez pas de code \u00e0 \u00e9crire pour l\u2019\u00e9chelle, le sol, ni les deux plates-formes. Le jeu est simple : l\u2019extraterrestre vert (joueur) doit aller chercher la clef sur la plate-forme pour ouvrir la porte. Il doit \u00e9viter les boules de feu envoy\u00e9es par la bernacle, l\u2019abeille et ne pas toucher aux pointes. Documents fournis: L'univers de jeu (fichier Scratch pour les \u00e9l\u00e8ves) La fiche de consigne Une grille d'\u00e9valuation","title":"\ud83d\udd79\ufe0f La cl\u00e9 des champs"},{"location":"SCRATCH/03-entrainements/#le-tresor-de-piggy","text":"ouvrir Dans cet univers de jeu, il y a 7 lutins \u00e0 animer: Piggy, le cochon ail\u00e9 qui sera dirig\u00e9 par le joueur Des obstacles (scie, pi\u00e8ge, poing et masse) Une pi\u00e8ce Un coffre Il y a \u00e9galement un lutin \u00ab texte \u00bb et un autre qui contient les sons. Le jeu \u00e0 cr\u00e9er est simple : Piggy doit r\u00e9cup\u00e9rer la pi\u00e8ce et l\u2019apporter dans le coffre tout en \u00e9vitant les obstacles, tous mortels. Les lutins ont beaucoup de costumes qu\u2019il faudra bien utiliser. Documents fournis : L'univers de jeu (fichier Scratch pour les \u00e9l\u00e8ves) La fiche de consigne Une grille d'\u00e9valuation","title":"\ud83d\udd79\ufe0f Le tr\u00e9sor de Piggy"},{"location":"SCRATCH/03-entrainements/#flappy-piggy","text":"ouvrir Dans cet univers de jeu, il y a 8 lutins \u00e0 utiliser : Piggy, le cochon ail\u00e9 qui sera dirig\u00e9 par le joueur ; des tuyaux (un seul lutin) ; deux lutins \u00ab sol \u00bb ; un lutin \u00ab Play \u00bb ; deux lutins \u00ab chiffres \u00bb pour afficher le score ; un lutin texte \u00ab Game over \u00bb. Chaque lutin contient les 4 sons \u00e0 disposition pour ce jeu. Le jeu \u00e0 cr\u00e9er est simple \u00e0 jouer, mais assez technique \u00e0 coder : Piggy doit passer entre les tuyaux sans les percuter. Documents fournis: L'univers de jeu (fichier Scratch pour les \u00e9l\u00e8ves) La fiche de consigne Une grille d'\u00e9valuation","title":"\ud83d\udd79\ufe0f Flappy Piggy"}]}